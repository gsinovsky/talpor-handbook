{
    "docs": [
        {
            "location": "/", 
            "text": "The talPor Philosophy\n\n\nIntroduction\n\n\nWhether you are onboarding on a new project, or just hotfixing a\nproblem in an old one, software development is \nhard\n.\n\n\nBuilding software is not only technically hard, but like any other\nproblem, it depends highly on the human factor. Successfully shaping and\ntaking ideas from just a thought all the way into a successful product\ninvolves tons of work. From the starting point, many variables, like\nyour client, developers, designers, among others, must be aligned\ntowards the goal of successfully shipping the product.\n\n\nThis document intends to outline what we believe to be the best\npractices at all the stages related to software development. As\nanything, it isn't written in stone, but rather is what we believe to\nbe sound advice in making software development successful.\n\n\nThe Guiding Principles\n\n\nAt \ntalPor\n, we function as a multi-disciplinary, distributed team.\nWe tend to work on small teams (generally, by project) which support and\ncollaborate with each other. These guiding principles, enumerated below, are the core of our philosophy. Embrace them, and\nput them to practice.\n\n\n\n\n\n\nDo not be afraid to make mistakes.\n Mistakes happen. You will\n   over or under-estimate that feature. You will completely\n   misunderstand your client. You will break a build for everyone in\n   your team. You will manage to take down production on a rainy\n   day. \nIt\n happens. And it will happen again. The whole point of\n   this philosophy is to \nminimize\n the number of times that happens.\n\n\n\n\n\n\nAlways try to do your best.\n Even if you have done it a million\n   times, or if it is the first time you get on board on a project,\n   always make solid decisions. It doesn't really matter if you have been\n   in the project from the get go, or you are just joining to hotfix\n   that annoying problem, take that extra time to first \nunderstand\n\n   the requirements, and then \nbuild\n or \nfix\n whatever needs to be\n   fixed as best as you possibly can.\n\n\n\n\n\n\nAsk for help.\n As previously said, we are a small team which is\n   always ready to provide help when needed. Don't be afraid to ask if\n   someone has ever done this or that. Don't be afraid to say you\n   don't know the answer. Don't be afraid to say you don't know how to\n   do something in particular. Likewise, offer your help or advice\n   when you do know what is going on.\n\n\n\n\n\n\nNever take it personally.\n This one is related to #1. It will\n   come the time when that feature branch you poured yourself into\n   will not make it to production. It will happen that your code will\n   take down production, or make the wrong assumptions. It will come\n   the time that you will be told you are doing it wrong. You are not\n   what you code or what you design, and you are not the project you\n   are on.\n\n\n\n\n\n\nBe impeccable with your words\n This one refers to the way you\n   express yourself. Words are much more than the constructs of phrases that\n   comes out of your mounth, they carry emotions, actions, thoughts or attitudes.\n   Express yourself with integrity, say what you mean and avoid your \nword\n to express\n   jealousy, envy, frustration, fear or anger. We respect each other ideas and thoughts.\n\n\n\n\n\n\nDon't make assumptions\n When you are working on teams, communication is\n   fundamental to guarantee success in any project. You cannot assume what\n   others think, so being a little verbose is not that bad. Misunderstandings\n   occurs and you may end up not deploying something into production\n   because you assumed that another one was going to do it.\n\n\n\n\n\n\nWho is this for?\n\n\nThis document is primarily geared towards any talPor employees. It is\nintended to contain glimpses of what we believe to be solid software\nengineering, from the project conception phase up to pivoting and\niterations of a project.\n\n\nAs such, anyone that partakes in any of the phases of software\ndevelopment, can benefit from reading and practicing what is on this\ndocument.\n\n\nHow is this document structured?\n\n\nThe rest of this document is structured trying to follow the common\nsoftware development flow.\n\n\n\n\n\n\nConception\n happens from the minute a new client\n   walks in, or a new internal project is started. Meeting the client, understanding\n   requirements, forming teams, estimating features all happens at\n   this stage.\n\n\n\n\n\n\nDevelopment\n is when the first version of the product\n   is built. Smart technology decisions, good practices, and impeccable communication\n   are key at this stage. This section is also were we go into detail about\n   the methodology we use during projects as well as best practices for development.\n\n\n\n\n\n\nDeployment\n of the project into production. Dealing with\n   showstopper bugs, the 90/10 rule, handling staging and production\n   servers, dealing with bugs on production, continuous integration.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-talpor-philosophy", 
            "text": "Introduction  Whether you are onboarding on a new project, or just hotfixing a\nproblem in an old one, software development is  hard .  Building software is not only technically hard, but like any other\nproblem, it depends highly on the human factor. Successfully shaping and\ntaking ideas from just a thought all the way into a successful product\ninvolves tons of work. From the starting point, many variables, like\nyour client, developers, designers, among others, must be aligned\ntowards the goal of successfully shipping the product.  This document intends to outline what we believe to be the best\npractices at all the stages related to software development. As\nanything, it isn't written in stone, but rather is what we believe to\nbe sound advice in making software development successful.  The Guiding Principles  At  talPor , we function as a multi-disciplinary, distributed team.\nWe tend to work on small teams (generally, by project) which support and\ncollaborate with each other. These guiding principles, enumerated below, are the core of our philosophy. Embrace them, and\nput them to practice.    Do not be afraid to make mistakes.  Mistakes happen. You will\n   over or under-estimate that feature. You will completely\n   misunderstand your client. You will break a build for everyone in\n   your team. You will manage to take down production on a rainy\n   day.  It  happens. And it will happen again. The whole point of\n   this philosophy is to  minimize  the number of times that happens.    Always try to do your best.  Even if you have done it a million\n   times, or if it is the first time you get on board on a project,\n   always make solid decisions. It doesn't really matter if you have been\n   in the project from the get go, or you are just joining to hotfix\n   that annoying problem, take that extra time to first  understand \n   the requirements, and then  build  or  fix  whatever needs to be\n   fixed as best as you possibly can.    Ask for help.  As previously said, we are a small team which is\n   always ready to provide help when needed. Don't be afraid to ask if\n   someone has ever done this or that. Don't be afraid to say you\n   don't know the answer. Don't be afraid to say you don't know how to\n   do something in particular. Likewise, offer your help or advice\n   when you do know what is going on.    Never take it personally.  This one is related to #1. It will\n   come the time when that feature branch you poured yourself into\n   will not make it to production. It will happen that your code will\n   take down production, or make the wrong assumptions. It will come\n   the time that you will be told you are doing it wrong. You are not\n   what you code or what you design, and you are not the project you\n   are on.    Be impeccable with your words  This one refers to the way you\n   express yourself. Words are much more than the constructs of phrases that\n   comes out of your mounth, they carry emotions, actions, thoughts or attitudes.\n   Express yourself with integrity, say what you mean and avoid your  word  to express\n   jealousy, envy, frustration, fear or anger. We respect each other ideas and thoughts.    Don't make assumptions  When you are working on teams, communication is\n   fundamental to guarantee success in any project. You cannot assume what\n   others think, so being a little verbose is not that bad. Misunderstandings\n   occurs and you may end up not deploying something into production\n   because you assumed that another one was going to do it.    Who is this for?  This document is primarily geared towards any talPor employees. It is\nintended to contain glimpses of what we believe to be solid software\nengineering, from the project conception phase up to pivoting and\niterations of a project.  As such, anyone that partakes in any of the phases of software\ndevelopment, can benefit from reading and practicing what is on this\ndocument.  How is this document structured?  The rest of this document is structured trying to follow the common\nsoftware development flow.    Conception  happens from the minute a new client\n   walks in, or a new internal project is started. Meeting the client, understanding\n   requirements, forming teams, estimating features all happens at\n   this stage.    Development  is when the first version of the product\n   is built. Smart technology decisions, good practices, and impeccable communication\n   are key at this stage. This section is also were we go into detail about\n   the methodology we use during projects as well as best practices for development.    Deployment  of the project into production. Dealing with\n   showstopper bugs, the 90/10 rule, handling staging and production\n   servers, dealing with bugs on production, continuous integration.", 
            "title": "The talPor Philosophy"
        }, 
        {
            "location": "/conception/", 
            "text": "The Conception Phase\n\n\nThe conception phase begins at the moment a new project walks through\nthe door. The main focus in this stage is understanding the\nrequirements of the project, and the results of this whole process is\na set of mockups and estimations that fulfills those requirements.\n\n\nDuring this stage, the team that will be involved in a project is\nbuilt, taking into consideration what is known initially. The idea is\nthat each team member strengths can be used to successfully take the\nproject from zero to production in reasonable time.\n\n\nAt talPor, this process is known as the \ndiscovery\n. During a\ndiscovery, fast paced meetings between the client and the team take\nplace with the goal of defining the requirements and defining what\nwill be part of the \nMVP (Minimum Viable Product)\n. These meetings\nshould be happening as fast as schedule permits.\n\n\nGenerally, clients will want to build every conceivable feature that\nis remotely related to their idea. As such, generally there is a lot\nof noise when you try to figure out what is the real problem the\nclient is trying to solve. At this stage you want to understand and\nisolate what is the big problem at hand, and provide the tools to\nsolve it.\n\n\nAlso remember, at the end of the day, we are also developing the\nclient idea. We are interested in the client to be successful, so we\nwant to be able, at the end of the development process and into the\nproduction stage, to (in)validate the path that has been chosen.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nListen to what the client says and want. \nTake notes\n.\n\n\n\n\n\n\nBe polite with your client but very assertive.\n\n\n\n\n\n\nExplain when something is not possible (or extremely hard).\n\n\n\n\n\n\nInvolve everybody, including the client, in the process. Don't take\n  ideas for granted, don't make assumptions, speak up when necessary.\n\n\n\n\n\n\nThe Feedback Loop\n\n\nThe feedback loop is the shape the discovery process takes as meetings\nwith the client take place. When the first meeting with the client\nhappens, it is expected that the client will talk and explain the\nproject to the team, while the team takes notes and asks questions. In\nthis meeting, most of the talk will be done by the client.\n\n\nAfter the first meeting, the team will start shaping up the\nrequirements the client talked about. Possibly, the team will come up\nwith wireframes or mockups, or some other way to visualize it. As the\nnext meeting with the client comes around (which should be as soon as\npossible), roles in the meeting slightly shift.\n\n\nDuring the second meeting, the team will present their mockups to the\nclient. It is expected that the client will have comments, questions\nor simply have more to add to what was already said. Again, the team\ntakes notes and gets the opportunity to ask more questions which help\nsolidify the vision of a project.\n\n\nThe internal work is repeated again, coming up with new visualizations\nof the requirements. As the next meeting comes around, the roles in\nthe meeting shift even more, with the team explaining the vision of\nthe requirements they have, and the client, ideally, aligning even\nfurther with that vision. More comments and questions can be posed by\nthe client, but ideally as every meeting with further developments\nhappen, the client will have less and less to say.\n\n\nThis loop continues, until a united vision between the team and the\nclient is agreed upon.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nPrepare before your client meeting and summarize what happens after\n  it.\n Take the time to do a short \npre-meeting\n with your teammates to\n  have a common understanding and goals in the meeting, and a short\n  \npost-meeting\n once the meeting is over.\n\n\n\n\n\n\nTry to validate your team hypothesis.\n For example, try to propose\n  stuff that is known to work instead of reinventing the wheel.\n\n\n\n\n\n\nUse what is available to you.\n If this is not a new project, ask to\n  see Google Analytics data, or any data that the project has\n  available. Make better hypothesis using this.\n\n\n\n\n\n\nAssume as little as possible.\n If you can't validate, it's just a\n  hunch.\n\n\n\n\n\n\nSometimes, the client doesn't want to let go of a feature they deem\n  really important. Try to compromise, try to explain why it is not\n  possible. Explain that if that feature makes it into the final\n  vision for the MVP, other features will have to be dropped for now.\n\n\n\n\n\n\nThe whole point of the discovery is to converge on a concrete but\n  not final vision for the project. Sometimes, your client will always\n  have something more to say, if possible listen, if not, remind them\n  that this is a MVP and more time to build other features will always\n  be there afterwards.\n\n\n\n\n\n\nRemind your client there is space for more development after the MVP\n  is done. The point of bounding the reach of the MVP is to be able to\n  \nvalidate as soon as possible\n rather than when multiple months of\n  development have been poured into the wrong hypothesis.\n\n\n\n\n\n\nMockups\n\n\nMockups are one of the deliverables of the discovery process. It\nshould represent a very basic view of the direction the team is taking\nwith the project. During the discovery process, mockups should be used\nto aid the delivery of the vision by the team.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nWhile simple, mockups should be sufficient to represent the vision\n  the project will take. Don't overlook details, but be pragmatic\n  about them.\n\n\n\n\n\n\nCurrently, we use \nBalsamiq Mockups\n to build\n  mockups.\n\n\n\n\n\n\nEstimations\n\n\nEstimations are one of the deliverables of the discovery process. At\ntalPor, we use a system of \nuser stories and story points\n to\nestimate the features to be done in a project. A user story is a sentence of\nthe form \"As a [actor], I want to [action]\". For example, one possible\nuser story is \"As a user, I want to log in\".\n\n\nEvery single feature that is proposed during the discovery process\nshould be turned into one or several user stories. Consider using\n\nthemes\n to classify user stories. For example, the previous user\nstory could be part of the \naccounts\n theme. \nEvery user story should\nbe estimated using story points.\n\n\nAt talPor we use a Fibonacci schemed story point system. We can assign\nto every task the following story points: 0, 0.5, 1, 2 (a day worth of\nwork), 3, 5, 8, 13, 20+ and ?. Our estimate is that every engineer can perform 10\nstory points a week, as such, assigning 8 to a task is saying it is\nexpected to take less than a week, and 13 more than one week.\n\n\nAssigning story points to a task should be done by the engineering\nteam physically at the same place (or via a video conference if not\npossible). Ideally, each team member should have an app, a set of cards or \npieces of paper with the possible story point values (0, 0.5, 1, 2, 3, ...) \nwritten on them.\n\n\nYou should start by agreeing upon a user story that you all\nestimate to be a 2, and another user story that you all estimate to be a 5.\nThe need for this is to set a baseline for comparison when estimating the\nremaining cards. Once these have been agreed upon, for each user story\nevery team member shows the card with the story points they believe the\nstory will take. If every member estimated the same, then the value is\nrecorded as the user story estimation. In case there was a disagreement,\na \nconsensus needs to be reached\n before an estimation can be recorded\nfor the user story.\n\n\nOnce every user story is estimated, some calculations should be done\nto figure out the expected standard deviation for the user\nstories. There are internal spreadsheets available to do this. Using\nthose calculations, an expected delivery time for all the user stories\ncan be estimated. You can find a spreadsheet with the formats and \nformulas used for \nuser stories\n estimations \nhere\n.\n\n\nProjects generally have a time frame. If the expected delivery time\nexceeds the project time frame, then further negotiation is needed\nbetween the team and client, even if a common vision was agreed upon\nby both parties. Common ways to do this include removing user stories\nor changing their scopes or reach.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nYour estimation will probably be wrong.\n Humans are exceptionally\n  bad at estimating time, especially under-estimating. Do your best to\n  keep the estimation as honest and real as possible.\n\n\n\n\n\n\nAccount for testing, deployment, bugfixing and other changes.\n\n  You will not always be building new features in the project. Account\n  for time building tests for the codebase, time spent making sure\n  deployment works, bugfixing or design changes.\n\n\n\n\n\n\nIf you find yourself using big story points for a user story, or\n  needing higher story points, consider splitting your user stories\n  into smaller more manageable user stories.\n\n\n\n\n\n\nKeep your estimations up-to-date in the project's \nTrello\n\n  board.", 
            "title": "Conception"
        }, 
        {
            "location": "/conception/#the-conception-phase", 
            "text": "The conception phase begins at the moment a new project walks through\nthe door. The main focus in this stage is understanding the\nrequirements of the project, and the results of this whole process is\na set of mockups and estimations that fulfills those requirements.  During this stage, the team that will be involved in a project is\nbuilt, taking into consideration what is known initially. The idea is\nthat each team member strengths can be used to successfully take the\nproject from zero to production in reasonable time.  At talPor, this process is known as the  discovery . During a\ndiscovery, fast paced meetings between the client and the team take\nplace with the goal of defining the requirements and defining what\nwill be part of the  MVP (Minimum Viable Product) . These meetings\nshould be happening as fast as schedule permits.  Generally, clients will want to build every conceivable feature that\nis remotely related to their idea. As such, generally there is a lot\nof noise when you try to figure out what is the real problem the\nclient is trying to solve. At this stage you want to understand and\nisolate what is the big problem at hand, and provide the tools to\nsolve it.  Also remember, at the end of the day, we are also developing the\nclient idea. We are interested in the client to be successful, so we\nwant to be able, at the end of the development process and into the\nproduction stage, to (in)validate the path that has been chosen.  Always keep in mind:    Listen to what the client says and want.  Take notes .    Be polite with your client but very assertive.    Explain when something is not possible (or extremely hard).    Involve everybody, including the client, in the process. Don't take\n  ideas for granted, don't make assumptions, speak up when necessary.    The Feedback Loop  The feedback loop is the shape the discovery process takes as meetings\nwith the client take place. When the first meeting with the client\nhappens, it is expected that the client will talk and explain the\nproject to the team, while the team takes notes and asks questions. In\nthis meeting, most of the talk will be done by the client.  After the first meeting, the team will start shaping up the\nrequirements the client talked about. Possibly, the team will come up\nwith wireframes or mockups, or some other way to visualize it. As the\nnext meeting with the client comes around (which should be as soon as\npossible), roles in the meeting slightly shift.  During the second meeting, the team will present their mockups to the\nclient. It is expected that the client will have comments, questions\nor simply have more to add to what was already said. Again, the team\ntakes notes and gets the opportunity to ask more questions which help\nsolidify the vision of a project.  The internal work is repeated again, coming up with new visualizations\nof the requirements. As the next meeting comes around, the roles in\nthe meeting shift even more, with the team explaining the vision of\nthe requirements they have, and the client, ideally, aligning even\nfurther with that vision. More comments and questions can be posed by\nthe client, but ideally as every meeting with further developments\nhappen, the client will have less and less to say.  This loop continues, until a united vision between the team and the\nclient is agreed upon.  Always keep in mind:    Prepare before your client meeting and summarize what happens after\n  it.  Take the time to do a short  pre-meeting  with your teammates to\n  have a common understanding and goals in the meeting, and a short\n   post-meeting  once the meeting is over.    Try to validate your team hypothesis.  For example, try to propose\n  stuff that is known to work instead of reinventing the wheel.    Use what is available to you.  If this is not a new project, ask to\n  see Google Analytics data, or any data that the project has\n  available. Make better hypothesis using this.    Assume as little as possible.  If you can't validate, it's just a\n  hunch.    Sometimes, the client doesn't want to let go of a feature they deem\n  really important. Try to compromise, try to explain why it is not\n  possible. Explain that if that feature makes it into the final\n  vision for the MVP, other features will have to be dropped for now.    The whole point of the discovery is to converge on a concrete but\n  not final vision for the project. Sometimes, your client will always\n  have something more to say, if possible listen, if not, remind them\n  that this is a MVP and more time to build other features will always\n  be there afterwards.    Remind your client there is space for more development after the MVP\n  is done. The point of bounding the reach of the MVP is to be able to\n   validate as soon as possible  rather than when multiple months of\n  development have been poured into the wrong hypothesis.    Mockups  Mockups are one of the deliverables of the discovery process. It\nshould represent a very basic view of the direction the team is taking\nwith the project. During the discovery process, mockups should be used\nto aid the delivery of the vision by the team.  Always keep in mind:    While simple, mockups should be sufficient to represent the vision\n  the project will take. Don't overlook details, but be pragmatic\n  about them.    Currently, we use  Balsamiq Mockups  to build\n  mockups.    Estimations  Estimations are one of the deliverables of the discovery process. At\ntalPor, we use a system of  user stories and story points  to\nestimate the features to be done in a project. A user story is a sentence of\nthe form \"As a [actor], I want to [action]\". For example, one possible\nuser story is \"As a user, I want to log in\".  Every single feature that is proposed during the discovery process\nshould be turned into one or several user stories. Consider using themes  to classify user stories. For example, the previous user\nstory could be part of the  accounts  theme.  Every user story should\nbe estimated using story points.  At talPor we use a Fibonacci schemed story point system. We can assign\nto every task the following story points: 0, 0.5, 1, 2 (a day worth of\nwork), 3, 5, 8, 13, 20+ and ?. Our estimate is that every engineer can perform 10\nstory points a week, as such, assigning 8 to a task is saying it is\nexpected to take less than a week, and 13 more than one week.  Assigning story points to a task should be done by the engineering\nteam physically at the same place (or via a video conference if not\npossible). Ideally, each team member should have an app, a set of cards or \npieces of paper with the possible story point values (0, 0.5, 1, 2, 3, ...) \nwritten on them.  You should start by agreeing upon a user story that you all\nestimate to be a 2, and another user story that you all estimate to be a 5.\nThe need for this is to set a baseline for comparison when estimating the\nremaining cards. Once these have been agreed upon, for each user story\nevery team member shows the card with the story points they believe the\nstory will take. If every member estimated the same, then the value is\nrecorded as the user story estimation. In case there was a disagreement,\na  consensus needs to be reached  before an estimation can be recorded\nfor the user story.  Once every user story is estimated, some calculations should be done\nto figure out the expected standard deviation for the user\nstories. There are internal spreadsheets available to do this. Using\nthose calculations, an expected delivery time for all the user stories\ncan be estimated. You can find a spreadsheet with the formats and \nformulas used for  user stories  estimations  here .  Projects generally have a time frame. If the expected delivery time\nexceeds the project time frame, then further negotiation is needed\nbetween the team and client, even if a common vision was agreed upon\nby both parties. Common ways to do this include removing user stories\nor changing their scopes or reach.  Always keep in mind:    Your estimation will probably be wrong.  Humans are exceptionally\n  bad at estimating time, especially under-estimating. Do your best to\n  keep the estimation as honest and real as possible.    Account for testing, deployment, bugfixing and other changes. \n  You will not always be building new features in the project. Account\n  for time building tests for the codebase, time spent making sure\n  deployment works, bugfixing or design changes.    If you find yourself using big story points for a user story, or\n  needing higher story points, consider splitting your user stories\n  into smaller more manageable user stories.    Keep your estimations up-to-date in the project's  Trello \n  board.", 
            "title": "The Conception Phase"
        }, 
        {
            "location": "/development/", 
            "text": "The Development Phase\n\n\nThe development phase begins immediately after conception, together\nwith design it makes up the core of the software development\nprocess. For software engineers, the development phase is their time\nto shine. In this stage, user stories are scheduled for development on\na week-by-week basis for the engineering team to work on. Initially,\nthe focus is on building the functionality of the MVP, while the design\nteam works in parallel designing the whole user interface and user\nexperience according to the user stories and mockups. Once the design\nteam starts producing designs, those are to be implemented into the final\nproduct that will be delivered.\n\n\nOnboarding\n\n\nRight before starting the development process, take the time to establish\nclear and redundant communication paths between the client and the team. \nIt is\npreferable to over-communicate than to under-communicate.\n\n\nGood communication is the #1 way to avoid overly long meetings and\nlast minute changes of heart. Involve the client, engage and\nlisten. Good communication between the team members avoids bugs and\nproblems down the road. As with the discovery meetings, take time to\nschedule \npre-\n and \npost-meetings\n where you review what was done and\nwhat will be done now.\n\n\nWhat you should do to onboard the project:\n\n\n\n\nSet up \nSlack\n for real time communication with the client.\n  This involves going to \nSlack\n and creating an account with\n  the name of the product or company (i.e. \nhttp://talpor.slack.com\n).\n\n\nSet up a board on \nTrello\n in the talPor organization to\n  track what is being done on the project. Create the recommended lists from our\n  \nTrello section\n of the methodology docs.\n\n\nUse the integrations between your tools, for example Slack-Trello integration\n  can be useful to notify the client new changes are deployed.\n\n\nSchedule a fixed day and time for the weekly meeting with your client.\n  \nBe on time\n. If you are being dilligent about keeping your communication\n  paths open, meetings should be just a summary of what was done and what is going\n  to be worked on during the week.\n\n\nSchedule meetings with your teammates before and after the weekly meeting.\n  Details on what to do at each of these meetings can be found in the\n  \nMeeting section\n of the Methodology docs.\n\n\n\n\nMethodology\n\n\nFor our development process we use an agile methodology. Our methodology draws\nfrom Scrum and Extreme Programming (XP), both well-known and well-documented\nagile methodologies. Therefore, to get details regarding our practices that\nescape the scope of this handbook, the documentation for these methodologies\nis the place to look.\n\n\nSo, what does using an agile methodology entail? It means we expect project\nrequirements to be constantly evolving and what we developed a week ago can be\nvery far from what we're building for tomorrow. You might be wondering:\n\n\"What the hell? How are you supposed to plan and build software under those\nconditions?\"\n. Well, we do.\n\n\nAgile methodologies were born out of the inability of other methodologies, like\nRUP or Waterfall, to adapt to unavoidable changes that occur while a product\nis being developed. So how do we handle this and keep our clients happy? We\nfollow incremental design guidelines and an iterative development process in\norder to minimize the risks that this constant evolution entails.\n\n\nThere are several techniques and weekly tasks that need to be followed as part\nof talPor's methodology so read on to the \nMethodology\n\nsection for further detail of what needs to be done during a project's life cycle.\n\n\nTechnical standards\n\n\nWe're a tech company that builds products and in order to deliver a great product\nwe need to be writing great code and using the best tools and software for the\njob. Also, in order to share our experience as a team, we need to be on the same\npage as to what software we're using as well as how we're using it. To accomplish\nboth those things we have a set of standards and recommendations that are documented\nin the \nTechnical Standards\n section.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/#the-development-phase", 
            "text": "The development phase begins immediately after conception, together\nwith design it makes up the core of the software development\nprocess. For software engineers, the development phase is their time\nto shine. In this stage, user stories are scheduled for development on\na week-by-week basis for the engineering team to work on. Initially,\nthe focus is on building the functionality of the MVP, while the design\nteam works in parallel designing the whole user interface and user\nexperience according to the user stories and mockups. Once the design\nteam starts producing designs, those are to be implemented into the final\nproduct that will be delivered.  Onboarding  Right before starting the development process, take the time to establish\nclear and redundant communication paths between the client and the team.  It is\npreferable to over-communicate than to under-communicate.  Good communication is the #1 way to avoid overly long meetings and\nlast minute changes of heart. Involve the client, engage and\nlisten. Good communication between the team members avoids bugs and\nproblems down the road. As with the discovery meetings, take time to\nschedule  pre-  and  post-meetings  where you review what was done and\nwhat will be done now.  What you should do to onboard the project:   Set up  Slack  for real time communication with the client.\n  This involves going to  Slack  and creating an account with\n  the name of the product or company (i.e.  http://talpor.slack.com ).  Set up a board on  Trello  in the talPor organization to\n  track what is being done on the project. Create the recommended lists from our\n   Trello section  of the methodology docs.  Use the integrations between your tools, for example Slack-Trello integration\n  can be useful to notify the client new changes are deployed.  Schedule a fixed day and time for the weekly meeting with your client.\n   Be on time . If you are being dilligent about keeping your communication\n  paths open, meetings should be just a summary of what was done and what is going\n  to be worked on during the week.  Schedule meetings with your teammates before and after the weekly meeting.\n  Details on what to do at each of these meetings can be found in the\n   Meeting section  of the Methodology docs.   Methodology  For our development process we use an agile methodology. Our methodology draws\nfrom Scrum and Extreme Programming (XP), both well-known and well-documented\nagile methodologies. Therefore, to get details regarding our practices that\nescape the scope of this handbook, the documentation for these methodologies\nis the place to look.  So, what does using an agile methodology entail? It means we expect project\nrequirements to be constantly evolving and what we developed a week ago can be\nvery far from what we're building for tomorrow. You might be wondering: \"What the hell? How are you supposed to plan and build software under those\nconditions?\" . Well, we do.  Agile methodologies were born out of the inability of other methodologies, like\nRUP or Waterfall, to adapt to unavoidable changes that occur while a product\nis being developed. So how do we handle this and keep our clients happy? We\nfollow incremental design guidelines and an iterative development process in\norder to minimize the risks that this constant evolution entails.  There are several techniques and weekly tasks that need to be followed as part\nof talPor's methodology so read on to the  Methodology \nsection for further detail of what needs to be done during a project's life cycle.  Technical standards  We're a tech company that builds products and in order to deliver a great product\nwe need to be writing great code and using the best tools and software for the\njob. Also, in order to share our experience as a team, we need to be on the same\npage as to what software we're using as well as how we're using it. To accomplish\nboth those things we have a set of standards and recommendations that are documented\nin the  Technical Standards  section.", 
            "title": "The Development Phase"
        }, 
        {
            "location": "/development/methodology/", 
            "text": "Introduction\n\n\nWhen you are working in a software development team you need a set of \nwell-defined processes to empower organization, communication and efficient \nwork. Moreover, inside a company, a standarized set of processes \naccross every team will allow every project to be treated the same way,\ndelivering the same quality and facilitating coordination among teams.\n\n\nDevelopers tends to be assigned to different projects from time to time, \nthe presence of these defined processes will make this migration smoothly\nas the organizational knowledge of a project should be the same of the \nther project. This set of processes is what we call the \nmethodology\n.\n\n\nThis section is intented to give a detailed description of our methodology,\nwhich entails every aspect of the way we work in talPor. We will describe \nhow we carry out our internals and clients meetings, how is our\nsetup for our agile development process, including the tools and processes \nwe use to guarantee the correct appliance of our methodology, as well as \nthe tools we use to gather internal feedback about the projects statuses.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/methodology/#introduction", 
            "text": "When you are working in a software development team you need a set of \nwell-defined processes to empower organization, communication and efficient \nwork. Moreover, inside a company, a standarized set of processes \naccross every team will allow every project to be treated the same way,\ndelivering the same quality and facilitating coordination among teams.  Developers tends to be assigned to different projects from time to time, \nthe presence of these defined processes will make this migration smoothly\nas the organizational knowledge of a project should be the same of the \nther project. This set of processes is what we call the  methodology .  This section is intented to give a detailed description of our methodology,\nwhich entails every aspect of the way we work in talPor. We will describe \nhow we carry out our internals and clients meetings, how is our\nsetup for our agile development process, including the tools and processes \nwe use to guarantee the correct appliance of our methodology, as well as \nthe tools we use to gather internal feedback about the projects statuses.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/methodology/meetings/", 
            "text": "Meetings\n\n\nMeetings are very important in the development process, they ensure that everybody\nis on the same page and we can received feedback from our clients. But at the same\ntime meetings can become a painful process were the team feels that it's losing\nvaluable time.\n\n\nMeeting tips\n\n\nBefore digging in to the particular process that we use at talPor,\nit would be useful to keep some tips in mind to transform meetings into a productive\ntool and a competitive advantage:\n\n\n\n\nStart on time and finish on time\n. People appreciate it when you understand that\n  their time is valuable. Another note on time: Do not schedule any meetings to last\n  longer than an hour. Sixty minutes is generally the longest time workers can\n  remain truly engaged.\n\n\nStick to your schedule\n. Create an agenda that lays out everything you plan\n  to cover in the meeting. Once you're in the meeting, put that agenda somewhere\n  accessible for everyone (Trello is a great alternative) and guide the flow of\n  the meeting according to the points that are reflected there. This keeps\n  people focused.\n\n\nIdentify who is responsible for leading each topic\n. Someone other than the\n  formal meeting leader is often responsible for leading the discussion of a\n  particular agenda item. This person may be providing context for the topic,\n  explaining data, or may have organizational responsibility for that area.\n  Identifying this person next to the agenda item ensures that anyone who is\n  responsible for leading part of the agenda knows it -- and prepares for it\n  -- before the meeting.\n\n\nRecap decisions and actions just before the meeting ends\n. For productive\n  meetings, the end is just as important as the beginning. Don't let people leave\n  the meeting in silent disagreement.\n\n\nFollow up\n. It's quite common for people to come away from the same meeting\n  with very different interpretations of what went on. To reduce this risk, use\n  Trello to highlight what was accomplished to all who attended, document the\n  responsibilities given, tasks delegated, and any assigned deadlines.\n  This way, everyone will be on the same page.\n\n\n\n\nWeekly Meetings\n\n\nAt talPor we use weekly meetings to keep track of the progress of each project.\nIdeally these meetings happen every week, at the same day, at the same time and\nare split into three meetings.\n\n\nPre-meeting\n\n\nThis meeting is just for the development team, it usually happens\njust before meeting with the client. The key objective here is to make sure that\nthe team is on the same page with the line of communication that is going to be\ndelivered to the client.  It's important that everyone is clear about what you\nwill and won't say as well as how things will be presented. Take time to prepare\nstrategies to confront possible problems or difficult situations that could arise\nduring the next meeting. Use the shared agenda with the client to make sure that\nyou can handle all the points reflected there. After the \"Pre-meeting\" the team\nhas to be able to explain the progress of the week, give feedback related to the\noverall scope of the project and have a proposal of what is going to be the\nfocus of the next week.\n\n\nClient Meeting\n\n\nAt this point the client joins the development team and the idea is to\nanswer the following questions\n\n\n\n\nWhat was last week's progress?\n\n\nDid we fulfill the expectations the team had? If we didn't, explain why and\n  how does that affects our schedule.\n\n\nHow are we in regards to our schedule?\n\n\nAre we meeting any particular deadline established with the client?\n\n\nIs there any change in the scope of the project?\n\n\nWhat is going to be the expectation for the next week?\n\n\n\n\nThis meeting is definitely key in the relationship with the clients, but it's\nimportant to maintain constant communication with them over the week to show\nany progress, because if we use this meeting to show new features the meeting\nis going to take a long time.\n\n\nSlack\n is your best tool for constant and effective communication.\n\n\nKeep the project's \nTrello\n board updated and do your best to\nengage the client there to receive as much feedback as possible before the meeting.\n\n\nPost-meeting\n\n\nThis happens immediately after the meeting with the client\nand is just for the development team. The goal is to make sure that everyone\nknows their respective responsibilities. Use this time to update Trello according\nto the feedback received in the previous meeting.", 
            "title": "Meetings"
        }, 
        {
            "location": "/development/methodology/meetings/#meetings", 
            "text": "Meetings are very important in the development process, they ensure that everybody\nis on the same page and we can received feedback from our clients. But at the same\ntime meetings can become a painful process were the team feels that it's losing\nvaluable time.  Meeting tips  Before digging in to the particular process that we use at talPor,\nit would be useful to keep some tips in mind to transform meetings into a productive\ntool and a competitive advantage:   Start on time and finish on time . People appreciate it when you understand that\n  their time is valuable. Another note on time: Do not schedule any meetings to last\n  longer than an hour. Sixty minutes is generally the longest time workers can\n  remain truly engaged.  Stick to your schedule . Create an agenda that lays out everything you plan\n  to cover in the meeting. Once you're in the meeting, put that agenda somewhere\n  accessible for everyone (Trello is a great alternative) and guide the flow of\n  the meeting according to the points that are reflected there. This keeps\n  people focused.  Identify who is responsible for leading each topic . Someone other than the\n  formal meeting leader is often responsible for leading the discussion of a\n  particular agenda item. This person may be providing context for the topic,\n  explaining data, or may have organizational responsibility for that area.\n  Identifying this person next to the agenda item ensures that anyone who is\n  responsible for leading part of the agenda knows it -- and prepares for it\n  -- before the meeting.  Recap decisions and actions just before the meeting ends . For productive\n  meetings, the end is just as important as the beginning. Don't let people leave\n  the meeting in silent disagreement.  Follow up . It's quite common for people to come away from the same meeting\n  with very different interpretations of what went on. To reduce this risk, use\n  Trello to highlight what was accomplished to all who attended, document the\n  responsibilities given, tasks delegated, and any assigned deadlines.\n  This way, everyone will be on the same page.   Weekly Meetings  At talPor we use weekly meetings to keep track of the progress of each project.\nIdeally these meetings happen every week, at the same day, at the same time and\nare split into three meetings.  Pre-meeting  This meeting is just for the development team, it usually happens\njust before meeting with the client. The key objective here is to make sure that\nthe team is on the same page with the line of communication that is going to be\ndelivered to the client.  It's important that everyone is clear about what you\nwill and won't say as well as how things will be presented. Take time to prepare\nstrategies to confront possible problems or difficult situations that could arise\nduring the next meeting. Use the shared agenda with the client to make sure that\nyou can handle all the points reflected there. After the \"Pre-meeting\" the team\nhas to be able to explain the progress of the week, give feedback related to the\noverall scope of the project and have a proposal of what is going to be the\nfocus of the next week.  Client Meeting  At this point the client joins the development team and the idea is to\nanswer the following questions   What was last week's progress?  Did we fulfill the expectations the team had? If we didn't, explain why and\n  how does that affects our schedule.  How are we in regards to our schedule?  Are we meeting any particular deadline established with the client?  Is there any change in the scope of the project?  What is going to be the expectation for the next week?   This meeting is definitely key in the relationship with the clients, but it's\nimportant to maintain constant communication with them over the week to show\nany progress, because if we use this meeting to show new features the meeting\nis going to take a long time.  Slack  is your best tool for constant and effective communication.  Keep the project's  Trello  board updated and do your best to\nengage the client there to receive as much feedback as possible before the meeting.  Post-meeting  This happens immediately after the meeting with the client\nand is just for the development team. The goal is to make sure that everyone\nknows their respective responsibilities. Use this time to update Trello according\nto the feedback received in the previous meeting.", 
            "title": "Meetings"
        }, 
        {
            "location": "/development/methodology/trello/", 
            "text": "\ufeffTrello\n\n\nThis section will define how we should be using Trello in our projects.\n\n\nNaming of Cards (US, Tasks)\n\n\nThe name of the card should contain a user story that somebody will have to do. This should be obtained from the requirements that the client needs.\n\n\nThe name of the card should be short but it needs to explain what is needed to be done, if there is some extra information that is needed to fully understand the task it should be written in the description of the card. The same way if there is document that is related to the task it should be attached to the card so the person responsible of making the task can easy access to it.\n\n\nIn order to have some traceability between the user story and the actual tasks that needed to be done to complete the user story those tasks whould be written inside the user story using a checklist. when a task is completed it should be marked as done and trello will show the percetage of the user story completed.\n\n\nDue to the fact that is impossible to split a card between weeks and is not sane to have a card in doing more than one week is necessary to update the \"actual effort made\" in the user story using the \"trello plugin for that\", in this way the difference between the \"story points\" and the \"actual effort made\" is the number of story points that will be used during the next week to complete the user story.\n\n\nThose tasks that are not part of a user story, like sys admin stuff, can be written in a card and we suggest to use a label so it can be easy to identify which cards are not a user story. The color suggested to identify this kind of cards is blue.\n\n\nUse of Trello in Weekly Meetings\n\n\nTrello is the main way in which we can communicate with the client about what we are currently doing, what we did and what we are going to do in the future. This means that that we need to keep it up to date and inform the client that he can keep an eye on the project at any moment just by looking at the cards on Trello.\n\n\nBefore every meeting we need to look at what is in Trello and what is the status of every card so we can give a correct information about the project to the client. Use trello to write the agenda of the meeting, in this way everybody can see what's happened in the previous meetings in an easy way. Also write in the agenda those aspects that comes out during the meeting as well as those aspects that needs to be done that aren't necessary a task.\n\n\nDuring the meeting you need to inform the client about the status of Trello which should also be the status of the project. Let the client ask questions about the cards and answer any doubts that come up. After the meeting you need to update Trello to reflect what is going to be done in the next iteration and estimate the corresponding cards.\n\n\nLists and meaning of lists\n\n\n1. \nBacklog:\n\n\nEvery task that defines the project should be here. If a task is not in the backlog (or any other list) it doesn't exist. Any idea, any \"nice to have\" feature, everything that should be included in the product at any point in the development should be there so everybody can track what the things that are left to complete the project are. The bugs that are found in the project should also be created in this list and must be marked with a \nBUG\n label, also we suggest to use the label red to identify this cards.\n\n\n2. \nToDo:\n\n\nIn this list should be the tasks that are going to be done in the current iteration. Those tasks should have been estimated in order to be sure that the iteration can be completed on time.\n\n\n3. \nDoing:\n\n\nAs soon as you begin to work on a task you should move it from \"ToDo\" to \"Doing\" as\nthis helps the team and the client, know what the current status of the iteration\nis as well what things the team is working on.\n\n\nAs development on the card advances, you need to tag the title of the card by adding\nthe number of story points of effort dedicated to the card, wrapped in brackets\n( \n[  ]\n, i.e. \n[8]\n). For example, if two days of work have been devoted to a\ncard estimated to take 8 story points and named \"\n(8) As a user I want to\nlogin\n\", you should update it to \"\n(8) As a user I want to login [4]\n\". This\nshould be done at the end of each week for all cards for which development has\nstarted or ended during that week.\n\n\nThis process is vital and should never be skipped since it provides important data\nabout how effectively the team is estimating cards and it allows the splitting of\ncards over the span of several weeks.\n\n\n4. \nPending Review (optional, to be reviewed by other dev):\n\n\nThe general idea behind this list is to add a step in the quality of the software that we are building. There are some things that the client can't or don't want to test, this things should be tested by someone different of the developer of the task. This is optional, it depends if the team is bigger than one developer and if there is time planned in the iteration to do this tests.\n\n\n5. \nTo be tested (to be reviewed and approved by client):\n\n\nThis tests are known as \"Acceptance Tests\", the client is the only one who knows what he really wants so it depends of him if the feature that we build satisfies his needs. Sometimes the client doesn't want to do the tests in the test server, but is really necessary to make him understands that this is the only way that we can be sure that we are building the right product.\n\n\n6. \nApproved (Ready for Deploy):\n\n\nThe client let the team knows that the card is approved by moving it from \"To be tested\" to \"Approved\". Only the client can move the cards to this list (Unless there is a previous agreement that another person can do it). The cards on this list can be deployed into production when the client needed to.\n\n\n\n\n\n\nCode is implemented and working.\n\n\n\n\n\n\nTests are written and passes.\n\n\n\n\n\n\nCode is live in the development (or staging) server.\n\n\n\n\n\n\n7. \nDone:\n\n\nHere should be the cards that are approved by the client and that are already in the production server. After the client approves the card, the person responsible of making the deploy into production should put the card in this list as soon as he finish the deploy (The features should be \n\"\nsmoke tested\n\"\n to be sure that everything is OK).\n\n\n\n\n\n\nTask was in Approved (ready for deploy).\n\n\n\n\n\n\nAcceptance test have been carried out by the client.\n\n\n\n\n\n\nCode is in production environment.\n\n\n\n\n\n\n8. \nAgenda:\n\n\nIn this list every card represents a meeting. Those cards contain the information about the points that were discussed in the meeting. The name of the card is the date in which the meeting occurs.\nUse a checklit to show the points to be discussed. Use the description to annotate any information relevant about the points of the meetings.\nYou can attach documents or make comments about the meeting using the corresponding feature in Trello.\nThese cards should be created before the meeting with the client, preferably during the team's pre-meeting.\n\n\nTips\n\n\nRemember that a tool is only useful if everyone uses it. Due to the fact that we are not in the same place we strongly depend on these kind of tools to be able to do our job in the best possible way. Do not hesitate to bring in new insights about how we can improve the way we use Trello or if there is another tool that can replace this and make our life easier.", 
            "title": "Trello"
        }, 
        {
            "location": "/development/methodology/trello/#trello", 
            "text": "This section will define how we should be using Trello in our projects.  Naming of Cards (US, Tasks)  The name of the card should contain a user story that somebody will have to do. This should be obtained from the requirements that the client needs.  The name of the card should be short but it needs to explain what is needed to be done, if there is some extra information that is needed to fully understand the task it should be written in the description of the card. The same way if there is document that is related to the task it should be attached to the card so the person responsible of making the task can easy access to it.  In order to have some traceability between the user story and the actual tasks that needed to be done to complete the user story those tasks whould be written inside the user story using a checklist. when a task is completed it should be marked as done and trello will show the percetage of the user story completed.  Due to the fact that is impossible to split a card between weeks and is not sane to have a card in doing more than one week is necessary to update the \"actual effort made\" in the user story using the \"trello plugin for that\", in this way the difference between the \"story points\" and the \"actual effort made\" is the number of story points that will be used during the next week to complete the user story.  Those tasks that are not part of a user story, like sys admin stuff, can be written in a card and we suggest to use a label so it can be easy to identify which cards are not a user story. The color suggested to identify this kind of cards is blue.  Use of Trello in Weekly Meetings  Trello is the main way in which we can communicate with the client about what we are currently doing, what we did and what we are going to do in the future. This means that that we need to keep it up to date and inform the client that he can keep an eye on the project at any moment just by looking at the cards on Trello.  Before every meeting we need to look at what is in Trello and what is the status of every card so we can give a correct information about the project to the client. Use trello to write the agenda of the meeting, in this way everybody can see what's happened in the previous meetings in an easy way. Also write in the agenda those aspects that comes out during the meeting as well as those aspects that needs to be done that aren't necessary a task.  During the meeting you need to inform the client about the status of Trello which should also be the status of the project. Let the client ask questions about the cards and answer any doubts that come up. After the meeting you need to update Trello to reflect what is going to be done in the next iteration and estimate the corresponding cards.  Lists and meaning of lists  1.  Backlog:  Every task that defines the project should be here. If a task is not in the backlog (or any other list) it doesn't exist. Any idea, any \"nice to have\" feature, everything that should be included in the product at any point in the development should be there so everybody can track what the things that are left to complete the project are. The bugs that are found in the project should also be created in this list and must be marked with a  BUG  label, also we suggest to use the label red to identify this cards.  2.  ToDo:  In this list should be the tasks that are going to be done in the current iteration. Those tasks should have been estimated in order to be sure that the iteration can be completed on time.  3.  Doing:  As soon as you begin to work on a task you should move it from \"ToDo\" to \"Doing\" as\nthis helps the team and the client, know what the current status of the iteration\nis as well what things the team is working on.  As development on the card advances, you need to tag the title of the card by adding\nthe number of story points of effort dedicated to the card, wrapped in brackets\n(  [  ] , i.e.  [8] ). For example, if two days of work have been devoted to a\ncard estimated to take 8 story points and named \" (8) As a user I want to\nlogin \", you should update it to \" (8) As a user I want to login [4] \". This\nshould be done at the end of each week for all cards for which development has\nstarted or ended during that week.  This process is vital and should never be skipped since it provides important data\nabout how effectively the team is estimating cards and it allows the splitting of\ncards over the span of several weeks.  4.  Pending Review (optional, to be reviewed by other dev):  The general idea behind this list is to add a step in the quality of the software that we are building. There are some things that the client can't or don't want to test, this things should be tested by someone different of the developer of the task. This is optional, it depends if the team is bigger than one developer and if there is time planned in the iteration to do this tests.  5.  To be tested (to be reviewed and approved by client):  This tests are known as \"Acceptance Tests\", the client is the only one who knows what he really wants so it depends of him if the feature that we build satisfies his needs. Sometimes the client doesn't want to do the tests in the test server, but is really necessary to make him understands that this is the only way that we can be sure that we are building the right product.  6.  Approved (Ready for Deploy):  The client let the team knows that the card is approved by moving it from \"To be tested\" to \"Approved\". Only the client can move the cards to this list (Unless there is a previous agreement that another person can do it). The cards on this list can be deployed into production when the client needed to.    Code is implemented and working.    Tests are written and passes.    Code is live in the development (or staging) server.    7.  Done:  Here should be the cards that are approved by the client and that are already in the production server. After the client approves the card, the person responsible of making the deploy into production should put the card in this list as soon as he finish the deploy (The features should be  \" smoke tested \"  to be sure that everything is OK).    Task was in Approved (ready for deploy).    Acceptance test have been carried out by the client.    Code is in production environment.    8.  Agenda:  In this list every card represents a meeting. Those cards contain the information about the points that were discussed in the meeting. The name of the card is the date in which the meeting occurs.\nUse a checklit to show the points to be discussed. Use the description to annotate any information relevant about the points of the meetings.\nYou can attach documents or make comments about the meeting using the corresponding feature in Trello.\nThese cards should be created before the meeting with the client, preferably during the team's pre-meeting.  Tips  Remember that a tool is only useful if everyone uses it. Due to the fact that we are not in the same place we strongly depend on these kind of tools to be able to do our job in the best possible way. Do not hesitate to bring in new insights about how we can improve the way we use Trello or if there is another tool that can replace this and make our life easier.", 
            "title": "\ufeffTrello"
        }, 
        {
            "location": "/development/methodology/done/", 
            "text": "Definition of done\n\n\nThe Definition of done is a concept extracted from the Agile Scrum methodology, it's crucial to a highly functioning agile team. It's defined as a set of criteria or checklist that should be met before a feature (usually a task or a User Story) is considered \nDone\n. With this in mind, everyone that is involved with the team will heave a common understanding of \"what's done\". It should be taken into account that a feature should be considered done when it is a \"potentially shippable\" feature or it's ready to be released.\n\n\nCurrently, we use the following criteria to specify if a feature is done:\n\n\n\n\nThe code for the featured was produced.\n\n\nTests written and passing.\n\n\nThe code is commited and pushed to the development repository.\n\n\nThe code is live in the development server.\n\n\nAcceptance tests have been carried out by the client.\n\n\nCode is merged and pushed into Production environment.\n\n\nCode is live into production environment.\n\n\n\n\n\n\nEvery task or feature must comply with the definition of done before consider it finished!", 
            "title": "Definition of Done"
        }, 
        {
            "location": "/development/methodology/done/#definition-of-done", 
            "text": "The Definition of done is a concept extracted from the Agile Scrum methodology, it's crucial to a highly functioning agile team. It's defined as a set of criteria or checklist that should be met before a feature (usually a task or a User Story) is considered  Done . With this in mind, everyone that is involved with the team will heave a common understanding of \"what's done\". It should be taken into account that a feature should be considered done when it is a \"potentially shippable\" feature or it's ready to be released.  Currently, we use the following criteria to specify if a feature is done:   The code for the featured was produced.  Tests written and passing.  The code is commited and pushed to the development repository.  The code is live in the development server.  Acceptance tests have been carried out by the client.  Code is merged and pushed into Production environment.  Code is live into production environment.    Every task or feature must comply with the definition of done before consider it finished!", 
            "title": "Definition of done"
        }, 
        {
            "location": "/development/methodology/post-mortem/", 
            "text": "The process\n\n\nAt the end of a project cycle or when somebody gets out of the project, we run a \nPost-Mortem\n or \nLessons learned\n process. \n\n\nThe \nPost-mortem\n is a valuable tool to ensure continuous improvement for a software development team. Although its name seems forbidding it's just a process to assess how a project went. Some people prefer to call it \nRetrospective\n instead because \nPost-Mortem\n seems to be a negative term that implies the death of a project.\n\n\nIn our case, we will stick to \nPost-Mortem\n or \nLessons learned\n since we actually run several retrospectives during the project lifespan and they have different approaches and goals than the ones being described here.\n\n\nIn talPor \nPost-Mortems\n are carried out in two phases. The first one is individual and consists in filling in a \nPost-Mortem report\n. Each project member provides his own reflection and assessment about the overall project arc in a way that we can discover what went well and whatf could be done better next time. The ultimate goal is \"lessons learned\" \u2014 a set of actionable ideas for improving the next project.  \n\n\nThe second phase consist in a \nPost-Mortem meeting\n, this is where the different reports outcomes are discussed and conclusions and \"lessons learned\" are drawn. \n\n\nThere are two different scenarios where the \nPost-Mortems\n are applied:\n\n\n\n\nA team member gets out of the project.\n\n\nThe project cycle ends or the project is finished.\n\n\n\n\nFor each scenario there is a different course of action. If a \nmember leaves the team\n his post-mortem report will be evaluated in the following \nRetrospective meeting\n. In this case, the retrospective meeting will consists on the post-mortem evaluation as first task, from which the outcomes will be used as input for the current retrospective where the ex-member is not bounded to participate.\n\n\nIn the case where the \nproject cycle ends or the project is finished\n we organize a \nPost-Mortem meeting\n as described before.\n\n\nPost-mortem report\n\n\nThe purpose of the Project's Post-Mortem Report is to record, in detail, the specific project activities that were most effective and those that require adjustments for future projects. It could be seen as an overall reflection of what's been going on with the project. The objective of this report is to inform the development teams about those important lessons learned during the development of the project (i.e. obstacles, challenges, successes, what could be done differently next time, etc.), in a way that we can avoid making the same mistakes and learn from them.\n\n\nIn talPor we have a custom post-mortem report template that is used to gather this information. This template is sent as a google questionnaire and its answers are stored in a google spreadsheet. You can make a copy of this \nquestionnaire\n for your project in order to carry out your own post-mortem process.\n\n\nPost-mortem meeting\n\n\nAfter all the post-mortem reports have been filled in, it's time to discuss and draw some team conclusions about the project. Once everyone have written the \npost-mortem report\n we are on the same page to discuss and derive some lessons learned about the process of the project. \n\n\nThe meeting has to be scheduled as soon as all the post-mortem reports have been filled and handed in. According to the following cases the meeting will have different formats:\n\n\n\n\n\n\nOne member leaves the team\n: In this case, the post-mortem report of the one who left will be discussed during the next \nretrospective\n meeting of the project. At the beginning of the retrospective meeting, the post-mortem report of this member is discussed and the conclusions of that discussion will feed the retrospective meeting that will be carried out. It's not necessary that this member participates in the entire retrospective meeting as he doesn't belong to the team anymore.\n\n\n\n\n\n\nThe project finishes or closes\n: A post-mortem meeting is set up in this case and no more retrospective meetings are carried out. In this meeting the results of each post-mortem report are discussed and some conclusions and lessons learned are drawn.", 
            "title": "Post-Mortem"
        }, 
        {
            "location": "/development/methodology/post-mortem/#the-process", 
            "text": "At the end of a project cycle or when somebody gets out of the project, we run a  Post-Mortem  or  Lessons learned  process.   The  Post-mortem  is a valuable tool to ensure continuous improvement for a software development team. Although its name seems forbidding it's just a process to assess how a project went. Some people prefer to call it  Retrospective  instead because  Post-Mortem  seems to be a negative term that implies the death of a project.  In our case, we will stick to  Post-Mortem  or  Lessons learned  since we actually run several retrospectives during the project lifespan and they have different approaches and goals than the ones being described here.  In talPor  Post-Mortems  are carried out in two phases. The first one is individual and consists in filling in a  Post-Mortem report . Each project member provides his own reflection and assessment about the overall project arc in a way that we can discover what went well and whatf could be done better next time. The ultimate goal is \"lessons learned\" \u2014 a set of actionable ideas for improving the next project.    The second phase consist in a  Post-Mortem meeting , this is where the different reports outcomes are discussed and conclusions and \"lessons learned\" are drawn.   There are two different scenarios where the  Post-Mortems  are applied:   A team member gets out of the project.  The project cycle ends or the project is finished.   For each scenario there is a different course of action. If a  member leaves the team  his post-mortem report will be evaluated in the following  Retrospective meeting . In this case, the retrospective meeting will consists on the post-mortem evaluation as first task, from which the outcomes will be used as input for the current retrospective where the ex-member is not bounded to participate.  In the case where the  project cycle ends or the project is finished  we organize a  Post-Mortem meeting  as described before.  Post-mortem report  The purpose of the Project's Post-Mortem Report is to record, in detail, the specific project activities that were most effective and those that require adjustments for future projects. It could be seen as an overall reflection of what's been going on with the project. The objective of this report is to inform the development teams about those important lessons learned during the development of the project (i.e. obstacles, challenges, successes, what could be done differently next time, etc.), in a way that we can avoid making the same mistakes and learn from them.  In talPor we have a custom post-mortem report template that is used to gather this information. This template is sent as a google questionnaire and its answers are stored in a google spreadsheet. You can make a copy of this  questionnaire  for your project in order to carry out your own post-mortem process.  Post-mortem meeting  After all the post-mortem reports have been filled in, it's time to discuss and draw some team conclusions about the project. Once everyone have written the  post-mortem report  we are on the same page to discuss and derive some lessons learned about the process of the project.   The meeting has to be scheduled as soon as all the post-mortem reports have been filled and handed in. According to the following cases the meeting will have different formats:    One member leaves the team : In this case, the post-mortem report of the one who left will be discussed during the next  retrospective  meeting of the project. At the beginning of the retrospective meeting, the post-mortem report of this member is discussed and the conclusions of that discussion will feed the retrospective meeting that will be carried out. It's not necessary that this member participates in the entire retrospective meeting as he doesn't belong to the team anymore.    The project finishes or closes : A post-mortem meeting is set up in this case and no more retrospective meetings are carried out. In this meeting the results of each post-mortem report are discussed and some conclusions and lessons learned are drawn.", 
            "title": "The process"
        }, 
        {
            "location": "/development/tech/", 
            "text": "Tech Standards\n\n\nSource Control\n\n\nFrom the get go, use version control. This is not negotiable. At\ntalPor we use \nGit\n exclusively. For open source code,\nwe publish at \nGitHub\n and for everything else we use\ninternal Git repositories.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nDon't rewrite public story!\n Bad stuff happens when you do that,\n    kittens die. Just don't do it.\n\n\n\n\n\n\nTry to make your commits as atomic as possible. If you feel like you\n  have many commits that don't quite work up to a feature (which you\n  have not yet pushed), you can squash them with a rebase.\n\n\n\n\n\n\nFollow \nGit Flow\n. However, we keep master as develop, and production as master. Use feature and hotfix branches.\n\n\n\n\n\n\nWrite good commit messages. Use a good headline and, if needed,\n  follow it by further details about the commit.\n\n\n\n\n\n\nCherish the existence of \ncherry-pick\n and \nbisect\n. Learn how and when\n  to use \nrebase\n and \nreset\n.\n\n\n\n\n\n\nTechnology Stack\n\n\nChoosing the project technology stack is one of the most important and\nlasting decisions of a project. It's almost cruel that such an\nimportant decision has to be made so early in a project life when so\nmany unknowns remain. When selecting the project technology stack,\nmany factors have to be balanced:\n\n\n\n\nStable tools with strong ecosystems and communities.\n\n\nTools which helps us develop fast, and iterate quickly.\n\n\nTools that will make us happy.\n\n\n\n\nMany times is easy to select the hip technology for a project that\nactually requires something radically different, and boring. Selecting\nthe technology stack is a lasting decision that should be \nagreed\nupon\n by the team members.\n\n\nThe following subsections list some of the common choices we have made\nat talPor, and some of the things to look out for.\n\n\nWeb apps\n\n\nWe are primarily a \nPython\n shop. We generally use\n\nDjango\n for our projects, although we have\nsuccessfully used \nFlask\n for smaller projects.\nAdditionally, we have dipped our toes in the \nNode.js\n and\n\nRails\n world with varying levels of success.\n\n\nWe prefer Python and Django on the backend because there are no\nsurprises. There is no magic, there are no strongly held opinions but\nrather a set of conventions to follow.\n\n\nOn the frontend, we use plain Javascript. We generally work on top of\na framework. We have used \nAngular\n,\n\nBackbone\n, and \nReact\n\nin the past. Styling is generally done using a combination of\n\nSASS\n and \nCompass\n.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nUse starting skeletons for your projects. For Django we have found a\n  lot of success using\n  \nCookiecutter Django\n\n  and for Javascript we have enjoyed using\n  \nYeoman Generators\n.\n\n\n\n\n\n\nBe pragmatic.\n Choose the right tool for the job.\n\n\n\n\n\n\nMobile apps\n\n\nMake the pragmatic choice. While the experience is always better on\nnative applications over hybrid applications, sometimes the choice has\nto be made in the interest of development time and resources.\n\n\nAt talPor we have taken on projects that were built on top of\n\nCordova\n using\n\nIonic Framework\n with great results.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nSelect with your current project in mind. If your project needs\n  access to the latest iOS or Android features which have not landed\n  yet on PhoneGap, maybe going native is the best choice.\n\n\n\n\n\n\nFrom a designer point-of-view, designing for Android and iOS are\n  completely different stories. From screen size to the expected user\n  experience, it's all different. Keep this in mind when you decide to\n  go hybrid route.\n\n\n\n\n\n\nDatabases\n\n\nWe are strongly biased towards using\n\nPostgres\n for every new project. There\nare some up and coming NoSQL stores, like Mongo, but we deem them a\nlittle too immature for production.\n\n\nHowever, we love and use \nRedis\n as a K-V store,\ngenerally for caching and the backend for job queues.\n\n\nTooling\n\n\nChoose tools that help you during all the project stages. Your tools\nshould help you while you are developing by providing a good\ndevelopment environment. Your tools should help you make the\ntransition from local to staging and production as painlessly as\npossible.\n\n\nWe primarily use \nFabric\n, on top of the\ncommon system tools we already have available. We also enjoy using\n\nDocker\n to aid environment\nreproducibility. Other great tools are \nGrunt\n\nand \nGulp\n.\n\n\nServices\n\n\nThere are several services that solve many common problems. Don't be\nafraid to use them if they save considerable amount of development\ntime. For example, \nMandrill\n solves the\nproblem of transactional email beautifully with almost no overhead in\nintegration with the existing codebase.\n\n\nAlways keep in mind:\n\n\n\n\nConsider using services that fix non mission critical parts of your\n  project. Evaluate them, and use them if they shorten your\n  development time.\n\n\n\n\nStyle\n\n\nWhatever your technology stack, write code as idiomatically as you\ncan. Dive into your technology stack code style, follow their style,\nand avoid making one sided decisions. As a common rule of thumb, when\nyou want to do something non-idiomatic, you should be able to first\nconvince a teddy bear and then convince a team member.\n\n\nIf you need to define code style for your project (i.e. we inherited a\ncode base), document it and follow it religiously.\n\n\nOver anything, \nemphasize clean code and readability\n. Use comments\nto explain non obvious code paths. \nDon't be clever\n. Don't over\noptimize for the 1% case, think of the 99% case. If the 1% case\nbecomes a reality, you will be thankful you didn't implement the\noverly complicated, obfuscated option but the easy to follow and to\nthe point option.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nMany languages have a style guide. For example, Python has\n  \nPEP-8\n.\n\n\n\n\n\n\nMany frameworks also have a style guide. For example, Django has its\n  \nCoding Style guidelines\n.\n\n\n\n\n\n\nThere are many community-driven and company-driven efforts to define\n  good style. We enjoy following AirBnB's\n  \nJavaScript Coding Style\n. Google\n  also maintains a repository of style guides for their C++, Python,\n  Angular projects, among others.\n\n\n\n\n\n\nWhen no obvious choice can be made regarding style, select a style\n  guide by consensus, and follow it religiously.\n\n\n\n\n\n\nUse linters. Set them up to follow the agreed upon code style in\n  your project. Add configuration files to your Git repositories if\n  necessary.\n\n\n\n\n\n\nCode Reviews\n\n\nCode reviews are what happens when another person looks at code you\nwant to commit or have already commited. The main reason to have code\nreviews is aid \ncode maintainability and catch problems early\n. In\nsmall teams, it ensures that at least two pair of eyes are familiar\nwith every bit of the codebase.\n\n\nAt the moment, code reviews happen on a request basis. We follow a\n\npre-commit\n, or \npre-push\n philosophy. When you want a code review,\nyou can either request it to one of your team members, or request it\nto another coworker. Once your code is approved by your reviewers, you\ncan proceed to merge your code with \nmaster\n.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nIt's easier (and faster) to request a code review on small changes\n  (less than 100 lines) than on a huge feature (over 1000\n  lines). \nPush early, and push often\n. If you anticipate a big\n  feature which you want to have code reviewed, start requesting code\n  reviews as soon as possible and work on them incrementally.\n\n\n\n\n\n\nPre-review your code.\n Everybody's time is valuable. Don't\n  request code reviews on code that doesn't follow code conventions,\n  lacks testing, or is sloppy. As a rule of thumb, ask yourself if you\n  would accept your code if you were the reviewer.\n\n\n\n\n\n\nIf you are reviewing code, handle requests promptly. If you don't\n  understand something stop early and ask for clarifications (either a\n  rewrite of that chunk, or better comment structure). \nDon't reject\n  code because you would have done it differently\n. The main purpose\n  of code reviews is to have \nmaintainable code\n.\n\n\n\n\n\n\nIf a reviewer and a reviewee can't agree over a point, bring a third\n  party (another reviewer) to mediate.\n\n\n\n\n\n\nTesting\n\n\nWe strive for 100% testing coverage. Write tests religiously for your\ncode. Test both your backend and frontend, your logic, and common code\npaths. Test for invalid inputs, and malicious inputs. \nTry to break\nyour code\n. It is a lot better if you break it locally, rather than\non production.\n\n\nWhile we are not strongly opinionated on the approach you take (TDD?\nBDD? Red-Green-Refactor?), your codebase should be tested\nagainst. Prefer throughly tested libraries, frameworks and apps over\npoorly tested ones.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nGood testing means shiping working code. \nBe religious about\n  testing your codebase.\n\n\n\n\n\n\nNo testing or poor, sloppy testing will result in bad code\nreviews. Respect your teammates time, write good tests.\n\n\n\n\n\n\nTesting is central to our continuous integration system. Lacking\n  tests means that we won't be able to catch regressions or problems\n  automatically.\n\n\n\n\n\n\nProvisioning and Reproducibility\n\n\nSpend time figuring out how to make the different environments in your\nproject easily reproducible. Getting someone on-board on the project\nshould be relatively fast and easy. Adding a new server should also be\nrelatively painless. Keep clear documentation on how to install a\ndevelopment environment and how to perform a staging and production\ndeploy.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nUse your technology stack dependency managers. For example, if you\n  are using python use \npip\n.\n\n\n\n\n\n\nThere are several up and coming projects that handle reproducible\n  environments. At talPor, we have successfully used\n  \nVagrant\n and\n  \nDocker\n in the past.\n\n\n\n\n\n\nTry to make your local environment as close to staging as possible\n  and staging as close to production as possible.\n\n\n\n\n\n\nBe pragmatic about the previous point. You don't need a load\n  balancer to run your local setup.\n\n\n\n\n\n\nRead on the deployment phase for more advice.\n\n\n\n\n\n\nStaging\n\n\nStaging (also known as development) is the environment where the\nclient can test the latest changes. Ideally, it is as similar to\nproduction as possible. Setting up a staging server should be a\nimmediate priority as soon as the development phase starts.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nKeeping staging up-to-date aids communication with your client\n. Bugs\n  and issues can be found faster, and dealt with on a timely fashion.\n\n\n\n\n\n\nStaging should always pass all tests!\n Everything on staging is a\n  \ncandidate\n release of your project. Treat this environment seriously:\n  as \nfew\n  bugs as possible should make it here.\n\n\n\n\n\n\nTo help automatically keep track of the previous point, we have\n  continuous integration/deployment tools set up in place. Read up on\n  the deployment phase for more advice.\n\n\n\n\n\n\nHotfixes\n\n\nThere are several ways to hotfix problems that can happen in\n\nproduction\n. If the problem is already fixed on \nmaster\n, the easiest\nway is to backport the changes. This can be done cherry-picking the\ncommits that fixes the problem (you are making atomic commits, right?)\n\n\nHowever, sometimes problems only happen or affect \nproduction\n, in\nthis case, you will need to track down the problem and prepare a\nhotfix branch. When you are done fixing the problem, make sure you\nmerge against production.\n\n\nAlways keep in mind:\n\n\n\n\nWhen hotfixing a problem, your tests should pass afterwards.\n\n\nIf new tests are needed, add them to your hotfix branch.\n\n\nUse \ngit cherry-pick -n\n to review the changes you are\n  cherry-picking before commiting them into your current branch.\n\n\n\n\nSecurity\n\n\nWhatever your project or application is, take a minute to understand\nthat what you are building will eventually have to deal with malicious\ninput and carefully crafted exploits. \nExpect the best, but prepare\nfor the worse.\n Test for malicious inputs, understand common attack\nvectors (XSS, CSRF, SQL Injections, man in the middle, ...) and\nmitigate them. Make sure you are \nalways\n testing users for the right\npermissions when trying to do something.\n\n\nUnderstand that data in production is extremely valuable, for you,\nyour client and your client's clients. \nMake scheduled backups and\nstore them off-site.\n\n\nUse SSL when dealing with sensitive information.\n Avoid storing\ncredit cards, or other sensitive information, and if you do, read on\nhow to do it \nsecurely\n. If you are processing payments, consider\nusing established carriers, like \nStripe\n.\n\n\nStay on top of CVEs and security releases related to your stack. This\nincludes system wide exploits related to your OS and libraries, and\nmaking sure your framework is running on the latest security release.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nSecurity is a process, not a result.\n Plan ahead, dip your toes\n  on the attack vectors, learn to mitigate them.\n\n\n\n\n\n\nFrameworks like Django offer many built-in security provisions. Use\n  them when possible.\n\n\n\n\n\n\nFollow sites which track security releases. Our internal\n  communication system is generally updated when a new vulnerability\n  or security release of common software in our stack is released.\n\n\n\n\n\n\nDon't roll out your own authenticating system.\n But if you manage\n  to convince anyone that this is a good idea, please use strong,\n  salted, one way ciphers to store user passwords.", 
            "title": "Tech Standards"
        }, 
        {
            "location": "/development/tech/#tech-standards", 
            "text": "Source Control  From the get go, use version control. This is not negotiable. At\ntalPor we use  Git  exclusively. For open source code,\nwe publish at  GitHub  and for everything else we use\ninternal Git repositories.  Always keep in mind:    Don't rewrite public story!  Bad stuff happens when you do that,\n    kittens die. Just don't do it.    Try to make your commits as atomic as possible. If you feel like you\n  have many commits that don't quite work up to a feature (which you\n  have not yet pushed), you can squash them with a rebase.    Follow  Git Flow . However, we keep master as develop, and production as master. Use feature and hotfix branches.    Write good commit messages. Use a good headline and, if needed,\n  follow it by further details about the commit.    Cherish the existence of  cherry-pick  and  bisect . Learn how and when\n  to use  rebase  and  reset .    Technology Stack  Choosing the project technology stack is one of the most important and\nlasting decisions of a project. It's almost cruel that such an\nimportant decision has to be made so early in a project life when so\nmany unknowns remain. When selecting the project technology stack,\nmany factors have to be balanced:   Stable tools with strong ecosystems and communities.  Tools which helps us develop fast, and iterate quickly.  Tools that will make us happy.   Many times is easy to select the hip technology for a project that\nactually requires something radically different, and boring. Selecting\nthe technology stack is a lasting decision that should be  agreed\nupon  by the team members.  The following subsections list some of the common choices we have made\nat talPor, and some of the things to look out for.  Web apps  We are primarily a  Python  shop. We generally use Django  for our projects, although we have\nsuccessfully used  Flask  for smaller projects.\nAdditionally, we have dipped our toes in the  Node.js  and Rails  world with varying levels of success.  We prefer Python and Django on the backend because there are no\nsurprises. There is no magic, there are no strongly held opinions but\nrather a set of conventions to follow.  On the frontend, we use plain Javascript. We generally work on top of\na framework. We have used  Angular , Backbone , and  React \nin the past. Styling is generally done using a combination of SASS  and  Compass .  Always keep in mind:    Use starting skeletons for your projects. For Django we have found a\n  lot of success using\n   Cookiecutter Django \n  and for Javascript we have enjoyed using\n   Yeoman Generators .    Be pragmatic.  Choose the right tool for the job.    Mobile apps  Make the pragmatic choice. While the experience is always better on\nnative applications over hybrid applications, sometimes the choice has\nto be made in the interest of development time and resources.  At talPor we have taken on projects that were built on top of Cordova  using Ionic Framework  with great results.  Always keep in mind:    Select with your current project in mind. If your project needs\n  access to the latest iOS or Android features which have not landed\n  yet on PhoneGap, maybe going native is the best choice.    From a designer point-of-view, designing for Android and iOS are\n  completely different stories. From screen size to the expected user\n  experience, it's all different. Keep this in mind when you decide to\n  go hybrid route.    Databases  We are strongly biased towards using Postgres  for every new project. There\nare some up and coming NoSQL stores, like Mongo, but we deem them a\nlittle too immature for production.  However, we love and use  Redis  as a K-V store,\ngenerally for caching and the backend for job queues.  Tooling  Choose tools that help you during all the project stages. Your tools\nshould help you while you are developing by providing a good\ndevelopment environment. Your tools should help you make the\ntransition from local to staging and production as painlessly as\npossible.  We primarily use  Fabric , on top of the\ncommon system tools we already have available. We also enjoy using Docker  to aid environment\nreproducibility. Other great tools are  Grunt \nand  Gulp .  Services  There are several services that solve many common problems. Don't be\nafraid to use them if they save considerable amount of development\ntime. For example,  Mandrill  solves the\nproblem of transactional email beautifully with almost no overhead in\nintegration with the existing codebase.  Always keep in mind:   Consider using services that fix non mission critical parts of your\n  project. Evaluate them, and use them if they shorten your\n  development time.   Style  Whatever your technology stack, write code as idiomatically as you\ncan. Dive into your technology stack code style, follow their style,\nand avoid making one sided decisions. As a common rule of thumb, when\nyou want to do something non-idiomatic, you should be able to first\nconvince a teddy bear and then convince a team member.  If you need to define code style for your project (i.e. we inherited a\ncode base), document it and follow it religiously.  Over anything,  emphasize clean code and readability . Use comments\nto explain non obvious code paths.  Don't be clever . Don't over\noptimize for the 1% case, think of the 99% case. If the 1% case\nbecomes a reality, you will be thankful you didn't implement the\noverly complicated, obfuscated option but the easy to follow and to\nthe point option.  Always keep in mind:    Many languages have a style guide. For example, Python has\n   PEP-8 .    Many frameworks also have a style guide. For example, Django has its\n   Coding Style guidelines .    There are many community-driven and company-driven efforts to define\n  good style. We enjoy following AirBnB's\n   JavaScript Coding Style . Google\n  also maintains a repository of style guides for their C++, Python,\n  Angular projects, among others.    When no obvious choice can be made regarding style, select a style\n  guide by consensus, and follow it religiously.    Use linters. Set them up to follow the agreed upon code style in\n  your project. Add configuration files to your Git repositories if\n  necessary.    Code Reviews  Code reviews are what happens when another person looks at code you\nwant to commit or have already commited. The main reason to have code\nreviews is aid  code maintainability and catch problems early . In\nsmall teams, it ensures that at least two pair of eyes are familiar\nwith every bit of the codebase.  At the moment, code reviews happen on a request basis. We follow a pre-commit , or  pre-push  philosophy. When you want a code review,\nyou can either request it to one of your team members, or request it\nto another coworker. Once your code is approved by your reviewers, you\ncan proceed to merge your code with  master .  Always keep in mind:    It's easier (and faster) to request a code review on small changes\n  (less than 100 lines) than on a huge feature (over 1000\n  lines).  Push early, and push often . If you anticipate a big\n  feature which you want to have code reviewed, start requesting code\n  reviews as soon as possible and work on them incrementally.    Pre-review your code.  Everybody's time is valuable. Don't\n  request code reviews on code that doesn't follow code conventions,\n  lacks testing, or is sloppy. As a rule of thumb, ask yourself if you\n  would accept your code if you were the reviewer.    If you are reviewing code, handle requests promptly. If you don't\n  understand something stop early and ask for clarifications (either a\n  rewrite of that chunk, or better comment structure).  Don't reject\n  code because you would have done it differently . The main purpose\n  of code reviews is to have  maintainable code .    If a reviewer and a reviewee can't agree over a point, bring a third\n  party (another reviewer) to mediate.    Testing  We strive for 100% testing coverage. Write tests religiously for your\ncode. Test both your backend and frontend, your logic, and common code\npaths. Test for invalid inputs, and malicious inputs.  Try to break\nyour code . It is a lot better if you break it locally, rather than\non production.  While we are not strongly opinionated on the approach you take (TDD?\nBDD? Red-Green-Refactor?), your codebase should be tested\nagainst. Prefer throughly tested libraries, frameworks and apps over\npoorly tested ones.  Always keep in mind:    Good testing means shiping working code.  Be religious about\n  testing your codebase.    No testing or poor, sloppy testing will result in bad code\nreviews. Respect your teammates time, write good tests.    Testing is central to our continuous integration system. Lacking\n  tests means that we won't be able to catch regressions or problems\n  automatically.    Provisioning and Reproducibility  Spend time figuring out how to make the different environments in your\nproject easily reproducible. Getting someone on-board on the project\nshould be relatively fast and easy. Adding a new server should also be\nrelatively painless. Keep clear documentation on how to install a\ndevelopment environment and how to perform a staging and production\ndeploy.  Always keep in mind:    Use your technology stack dependency managers. For example, if you\n  are using python use  pip .    There are several up and coming projects that handle reproducible\n  environments. At talPor, we have successfully used\n   Vagrant  and\n   Docker  in the past.    Try to make your local environment as close to staging as possible\n  and staging as close to production as possible.    Be pragmatic about the previous point. You don't need a load\n  balancer to run your local setup.    Read on the deployment phase for more advice.    Staging  Staging (also known as development) is the environment where the\nclient can test the latest changes. Ideally, it is as similar to\nproduction as possible. Setting up a staging server should be a\nimmediate priority as soon as the development phase starts.  Always keep in mind:    Keeping staging up-to-date aids communication with your client . Bugs\n  and issues can be found faster, and dealt with on a timely fashion.    Staging should always pass all tests!  Everything on staging is a\n   candidate  release of your project. Treat this environment seriously:\n  as  few   bugs as possible should make it here.    To help automatically keep track of the previous point, we have\n  continuous integration/deployment tools set up in place. Read up on\n  the deployment phase for more advice.    Hotfixes  There are several ways to hotfix problems that can happen in production . If the problem is already fixed on  master , the easiest\nway is to backport the changes. This can be done cherry-picking the\ncommits that fixes the problem (you are making atomic commits, right?)  However, sometimes problems only happen or affect  production , in\nthis case, you will need to track down the problem and prepare a\nhotfix branch. When you are done fixing the problem, make sure you\nmerge against production.  Always keep in mind:   When hotfixing a problem, your tests should pass afterwards.  If new tests are needed, add them to your hotfix branch.  Use  git cherry-pick -n  to review the changes you are\n  cherry-picking before commiting them into your current branch.   Security  Whatever your project or application is, take a minute to understand\nthat what you are building will eventually have to deal with malicious\ninput and carefully crafted exploits.  Expect the best, but prepare\nfor the worse.  Test for malicious inputs, understand common attack\nvectors (XSS, CSRF, SQL Injections, man in the middle, ...) and\nmitigate them. Make sure you are  always  testing users for the right\npermissions when trying to do something.  Understand that data in production is extremely valuable, for you,\nyour client and your client's clients.  Make scheduled backups and\nstore them off-site.  Use SSL when dealing with sensitive information.  Avoid storing\ncredit cards, or other sensitive information, and if you do, read on\nhow to do it  securely . If you are processing payments, consider\nusing established carriers, like  Stripe .  Stay on top of CVEs and security releases related to your stack. This\nincludes system wide exploits related to your OS and libraries, and\nmaking sure your framework is running on the latest security release.  Always keep in mind:    Security is a process, not a result.  Plan ahead, dip your toes\n  on the attack vectors, learn to mitigate them.    Frameworks like Django offer many built-in security provisions. Use\n  them when possible.    Follow sites which track security releases. Our internal\n  communication system is generally updated when a new vulnerability\n  or security release of common software in our stack is released.    Don't roll out your own authenticating system.  But if you manage\n  to convince anyone that this is a good idea, please use strong,\n  salted, one way ciphers to store user passwords.", 
            "title": "Tech Standards"
        }, 
        {
            "location": "/deployment/", 
            "text": "The Deployment Phase\n\n\nA deploy is when you push your local changes to either the\nstaging/development server or the production server. It doesn't just\nhappen just the once when everything is done, but it's an event that\nhappens regularly, specially when you are pushing changes from local\nto staging. When you push to production you should take extra care\nbecause you might be dealing with real data from your client.\n\n\nAs a rule of thumb, we generally use AWS for all our servers since it\nprovides the highest level of flexibility and scalability you might\npossibly need.\n\n\nThe Checklist\n\n\nThis checklist is a list of stuff to make sure you are doing (or not\nand why) when setting up or deploying to a server.\n\n\n\n\n\n\nMake sure you disable password logins through SSH. \nEnable public\n  key authentication only\n. Don't change SSH server port from 22 to\n  anything else: \nSecurity by obfuscation is not security.\n\n\n\n\n\n\nUse \nsudo\n and use a good password for both your public key and\n  your account.\n\n\n\n\n\n\nSetup your firewall. Generally you'll want to block everything\n  except ports 22 (SSH), 80 (HTTP) and 443 (HTTPS).\n\n\n\n\n\n\nSetup NGINX as a reverse proxy to your application server.\n\n\n\n\n\n\nProduction should always use a trusted HTTPS certificate. Make sure\n  to get it and set it up.\n\n\n\n\n\n\nRedis is a sweet piece of software. It's so good and versatile that\n  you can use it from a cache backend to a job queue backend. Figure\n  out if you need it in your stack and set it up.\n\n\n\n\n\n\nMake sure we do not leak secrets. \nMake sure that if an API key is\n  accessible by untrusted agents then it is a public key\n. Don't\n  version control secrets. \nUse environment variables to store secret\n  keys.\n\n\n\n\n\n\nSetup automatic backups for production.\n Backup both the\n  database, and user generated content and store it \noffsite.\n\n\n\n\n\n\nLog everything. Read on Logging \n Errors below.\n\n\n\n\n\n\nAutomate your usual deploy process. We suggest using Fabric for\n  this.\n\n\n\n\n\n\nProvisioning\n\n\nWe have a set of Salt states to help with provisioning servers with\nsecure defaults. Don't be afraid to ask for them. There's an ongoing\ninternal effort to move application servers into isolated containers\n(e.g. using Docker). If that sounds interesting, don't be afraid to\nask about that either. Many of our tools, for example our CI pipeline,\nis built around the assumption that you are using Docker, so it might\nbe a good idea to use Docker from the get go.\n\n\nErrors and Logging\n\n\nAs a general rule of thumb, log everything. Log errors and\nnotices. Use your stack standard way to do this, \ndon't just spill\nprint statements all over the place.\n If you are doing something\ncritical, like handling payments, make sure you log the transaction\nonce on a log file and once on your database.\n\n\nWe internally use sentry for error logging and notification. Setup a\ndifferent DSN for each of your servers and respond to errors swiftly.", 
            "title": "The Deployment Phase"
        }, 
        {
            "location": "/deployment/#the-deployment-phase", 
            "text": "A deploy is when you push your local changes to either the\nstaging/development server or the production server. It doesn't just\nhappen just the once when everything is done, but it's an event that\nhappens regularly, specially when you are pushing changes from local\nto staging. When you push to production you should take extra care\nbecause you might be dealing with real data from your client.  As a rule of thumb, we generally use AWS for all our servers since it\nprovides the highest level of flexibility and scalability you might\npossibly need.  The Checklist  This checklist is a list of stuff to make sure you are doing (or not\nand why) when setting up or deploying to a server.    Make sure you disable password logins through SSH.  Enable public\n  key authentication only . Don't change SSH server port from 22 to\n  anything else:  Security by obfuscation is not security.    Use  sudo  and use a good password for both your public key and\n  your account.    Setup your firewall. Generally you'll want to block everything\n  except ports 22 (SSH), 80 (HTTP) and 443 (HTTPS).    Setup NGINX as a reverse proxy to your application server.    Production should always use a trusted HTTPS certificate. Make sure\n  to get it and set it up.    Redis is a sweet piece of software. It's so good and versatile that\n  you can use it from a cache backend to a job queue backend. Figure\n  out if you need it in your stack and set it up.    Make sure we do not leak secrets.  Make sure that if an API key is\n  accessible by untrusted agents then it is a public key . Don't\n  version control secrets.  Use environment variables to store secret\n  keys.    Setup automatic backups for production.  Backup both the\n  database, and user generated content and store it  offsite.    Log everything. Read on Logging   Errors below.    Automate your usual deploy process. We suggest using Fabric for\n  this.    Provisioning  We have a set of Salt states to help with provisioning servers with\nsecure defaults. Don't be afraid to ask for them. There's an ongoing\ninternal effort to move application servers into isolated containers\n(e.g. using Docker). If that sounds interesting, don't be afraid to\nask about that either. Many of our tools, for example our CI pipeline,\nis built around the assumption that you are using Docker, so it might\nbe a good idea to use Docker from the get go.  Errors and Logging  As a general rule of thumb, log everything. Log errors and\nnotices. Use your stack standard way to do this,  don't just spill\nprint statements all over the place.  If you are doing something\ncritical, like handling payments, make sure you log the transaction\nonce on a log file and once on your database.  We internally use sentry for error logging and notification. Setup a\ndifferent DSN for each of your servers and respond to errors swiftly.", 
            "title": "The Deployment Phase"
        }, 
        {
            "location": "/deployment/continuous-integration/", 
            "text": "Continuous Integration at talPor\n\n\nThis is an overview of how Continuous Integration (CI) is done at\ntalPor. All that is documented here is basically what we believe to be\nthe best approach for integrating your project into our internal CI\nworkflow. Read it, and make the changes you believe are needed for\nyour project.\n\n\nTechnology choices\n\n\nThis is an opinionated document. While we don't force you to use any\nof the stuff that is talked about in here, the tools we have developed\nassume many of the practices we preach about here. Particularly, our\ntechnology choices are based around the internal desire of simple\nreproducibility and commitment to ship better software that scales\ngracefully.\n\n\nThe only technology choice that cannot be avoided is \nJenkins\n as it\nis the selected CI workhorse. Besides that, all choices can be changed\nas needed. However, in this document we assume the following:\n\n\n\n\n\n\nDocker from development to production\n. Every possible\n   environment has a relevant image. Every process is dockerized into a\n   container. We recommend using our \ndocker registry\n to store\n   images and share them with your peers and between servers.\n\n\n\n\n\n\nFabric\n is used to encapsulate steps in the workflow and help\n   keep things reproducible. \nHelper tasks\n are maintained by our\n   developers.\n\n\n\n\n\n\nVersion Controlling for Good CI\n\n\nThe general idea of a CI workflow is as follows:\n\n\ngit push origin master -\n Begin CI Pipeline -\n If everything is OK (i.e. all tests pass) -\n\nPush new build\n\n\nAt talPor, we follow Git Flow. As it is recommended, we have a\nmainline which is what production is currently running, and a\ndevelopment line which is where all development happens. Our mainline\nbranch is called \nproduction\n and our development branch is called\n\ndevelopment\n (some projects call it staging). As can be expected,\nproduction servers run on top of the \nproduction\n branch, and\ndevelopment/staging servers run on top of the \ndevelopment\n branch.\n\n\nDevelopers create feature branches on top of \ndevelopment\n. When a new\nfeature is ready, it is merged into \ndevelopment\n.  When a new push is\nready to be made to production, \ndevelopment\n is merged into it and\nthen pushed. A similar process happens when there is a hotfix that\nneeds to be applied.\n\n\nWe have extended Git Flow to follow a better suited CI flow. The\ngeneral idea of CI is that every change that makes it into \ndevelopment\n\nand \nproduction\n should be as problem-free as possible. As such, we have\ndecided to make the invariant of the \ndevelopment\n branch the following:\n\n\nAt any given moment, \ndevelopment\n is a candidate release of the project.\n\n\nAs such, \ndevelopment\n should be ready to be merged into \nproduction\n\nand be as problem-free as possible. We define \nproblem-free\n as \nall\ntests pass\n. To avoid human error (merges when some test fails), when\nusing CI, \ndevelopment\n is handled by a machine (i.e. changes are\npushed by Jenkins), and \nit is not allowed to manually push changes\ninto it\n. To allow for development to happen, we have added a new\nbranch, \nmaster\n, in which development continues normally.\n\n\nStacking Environments\n\n\nIf you are using Docker containers, we strongly suggest you\nencapsulate your environments into different images for each\nenvironment. Try to move common and repeated behavior into common\nimages, and extend those images.\n\n\n\n\n\n\nCommon.\n The common steps in all your images. This is the root of\n  your build tree. Common tasks to perform here are installing system\n  dependencies and setting up global environment variables.\n\n\n\n\n\n\nLocal (extends Common).\n The environment developers will use in\n  their personal machines. Common tasks to perform here are installing\n  developer tools and requirements for local.\n\n\n\n\n\n\nTesting (extends Common).\n The environment where tests are\n  run. This environment is central to CI. Make sure running your tests\n  is the entrypoint for this environment.\n\n\n\n\n\n\nProduction (extends Common).\n The environment used by production\n  servers.\n\n\n\n\n\n\nDevelopment (extends Production).\n The environment used in\n  staging or development servers. Should be as similar to production\n  as possible.\n\n\n\n\n\n\nSince keeping all your environment up-to-date can be a hassle, we have\nan internal Docker registry where we store the latest images so they\ncan be pulled from as soon as a build is done.\n\n\nThe Generic Pipeline\n\n\nOur recommended CI pipeline for our software projects is described\nbelow. The first step is triggered when a push with changes on\n\nmaster\n is received.\n\n\n\n\n\n\nBuild new Docker images, if necessary.\n Checks into the new\n   pushed files are performed to detect whether or not to trigger a\n   build. \nOnly relevant environment should be rebuilt\n. For\n   example, if the Common needs to be rebuilt, every image needs to be\n   rebuilt, but if the Production image needs to be rebuilt, only\n   Production and Development needs rebuilding. If any image fails to\n   be built, the pipeline is stopped, and developers notified.\n\n\n\n\n\n\nRun Tests.\n Using your Testing environment, spin a new\n   container, and wait for tests to run. If all tests pass, move to\n   step 3. If any test fail, then notify developers a build has failed\n   to build.\n\n\n\n\n\n\nPush changes.\n Merge \nmaster\n into development (those changes\n   don't break anything), and push all the rebuilt images to the\n   registry.\n\n\n\n\n\n\nDeploy\n. Deploy changes to all the environment you want. By\n   default, we suggest automatically pushing into staging/development\n   and manually pushing to production when wanted.\n\n\n\n\n\n\nNotifications \n Broken Builds\n\n\nNotifications happen any time that a build fails. \nWhen a build\nfails, the whole team should focus on making \nmaster\n succesfully\nbuild again\n. Notifications are sent via email to developers and team\nmembers, and Slack spam happens. \nDon't ignore broken builds.", 
            "title": "Continuous Integration"
        }, 
        {
            "location": "/deployment/continuous-integration/#continuous-integration-at-talpor", 
            "text": "This is an overview of how Continuous Integration (CI) is done at\ntalPor. All that is documented here is basically what we believe to be\nthe best approach for integrating your project into our internal CI\nworkflow. Read it, and make the changes you believe are needed for\nyour project.  Technology choices  This is an opinionated document. While we don't force you to use any\nof the stuff that is talked about in here, the tools we have developed\nassume many of the practices we preach about here. Particularly, our\ntechnology choices are based around the internal desire of simple\nreproducibility and commitment to ship better software that scales\ngracefully.  The only technology choice that cannot be avoided is  Jenkins  as it\nis the selected CI workhorse. Besides that, all choices can be changed\nas needed. However, in this document we assume the following:    Docker from development to production . Every possible\n   environment has a relevant image. Every process is dockerized into a\n   container. We recommend using our  docker registry  to store\n   images and share them with your peers and between servers.    Fabric  is used to encapsulate steps in the workflow and help\n   keep things reproducible.  Helper tasks  are maintained by our\n   developers.    Version Controlling for Good CI  The general idea of a CI workflow is as follows:  git push origin master -  Begin CI Pipeline -  If everything is OK (i.e. all tests pass) - \nPush new build  At talPor, we follow Git Flow. As it is recommended, we have a\nmainline which is what production is currently running, and a\ndevelopment line which is where all development happens. Our mainline\nbranch is called  production  and our development branch is called development  (some projects call it staging). As can be expected,\nproduction servers run on top of the  production  branch, and\ndevelopment/staging servers run on top of the  development  branch.  Developers create feature branches on top of  development . When a new\nfeature is ready, it is merged into  development .  When a new push is\nready to be made to production,  development  is merged into it and\nthen pushed. A similar process happens when there is a hotfix that\nneeds to be applied.  We have extended Git Flow to follow a better suited CI flow. The\ngeneral idea of CI is that every change that makes it into  development \nand  production  should be as problem-free as possible. As such, we have\ndecided to make the invariant of the  development  branch the following:  At any given moment,  development  is a candidate release of the project.  As such,  development  should be ready to be merged into  production \nand be as problem-free as possible. We define  problem-free  as  all\ntests pass . To avoid human error (merges when some test fails), when\nusing CI,  development  is handled by a machine (i.e. changes are\npushed by Jenkins), and  it is not allowed to manually push changes\ninto it . To allow for development to happen, we have added a new\nbranch,  master , in which development continues normally.  Stacking Environments  If you are using Docker containers, we strongly suggest you\nencapsulate your environments into different images for each\nenvironment. Try to move common and repeated behavior into common\nimages, and extend those images.    Common.  The common steps in all your images. This is the root of\n  your build tree. Common tasks to perform here are installing system\n  dependencies and setting up global environment variables.    Local (extends Common).  The environment developers will use in\n  their personal machines. Common tasks to perform here are installing\n  developer tools and requirements for local.    Testing (extends Common).  The environment where tests are\n  run. This environment is central to CI. Make sure running your tests\n  is the entrypoint for this environment.    Production (extends Common).  The environment used by production\n  servers.    Development (extends Production).  The environment used in\n  staging or development servers. Should be as similar to production\n  as possible.    Since keeping all your environment up-to-date can be a hassle, we have\nan internal Docker registry where we store the latest images so they\ncan be pulled from as soon as a build is done.  The Generic Pipeline  Our recommended CI pipeline for our software projects is described\nbelow. The first step is triggered when a push with changes on master  is received.    Build new Docker images, if necessary.  Checks into the new\n   pushed files are performed to detect whether or not to trigger a\n   build.  Only relevant environment should be rebuilt . For\n   example, if the Common needs to be rebuilt, every image needs to be\n   rebuilt, but if the Production image needs to be rebuilt, only\n   Production and Development needs rebuilding. If any image fails to\n   be built, the pipeline is stopped, and developers notified.    Run Tests.  Using your Testing environment, spin a new\n   container, and wait for tests to run. If all tests pass, move to\n   step 3. If any test fail, then notify developers a build has failed\n   to build.    Push changes.  Merge  master  into development (those changes\n   don't break anything), and push all the rebuilt images to the\n   registry.    Deploy . Deploy changes to all the environment you want. By\n   default, we suggest automatically pushing into staging/development\n   and manually pushing to production when wanted.    Notifications   Broken Builds  Notifications happen any time that a build fails.  When a build\nfails, the whole team should focus on making  master  succesfully\nbuild again . Notifications are sent via email to developers and team\nmembers, and Slack spam happens.  Don't ignore broken builds.", 
            "title": "Continuous Integration at talPor"
        }, 
        {
            "location": "/wrapup/", 
            "text": "Goodbye\n\n\ntalPor\n strongly believes that you build the company you want\nto work for. As such, we are constantly iterating, testing new hypothesis, and\nvalidating. This document is always-changing, and we welcome thoughts,\nideas, and suggestions to improve our process.\n\n\nReferences\n\n\n\n\nTrello\n\n\nSlack\n\n\nGit\n\n\nGit Flow\n\n\ntalPor\n\n\nGitHub\n\n\npip\n\n\nDocker\n\n\nVagrant\n\n\nDjango\n\n\nPython\n\n\nFlask\n\n\nNode.js\n\n\nRails\n\n\nCompass\n\n\nSASS\n\n\nAngular\n\n\nBackbone\n\n\nReact\n\n\nStripe", 
            "title": "Wrap-up"
        }
    ]
}