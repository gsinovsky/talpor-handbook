{
    "docs": [
        {
            "location": "/", 
            "text": "The talPor Philosophy\n\n\nIntroduction\n\n\nWhether you are onboarding on a new project, or just hotfixing a\nproblem in an old one, software development is \nhard\n.\n\n\nBuilding software is not only technically hard, but is, like any other\nproblem, highly depend on the human factor. Successfully shaping and\ntaking ideas from just a thought all the way into a successful product\ninvolves tons of work. From the starting point, many variables, like\nyour client, developers, designers, among others, must be aligned\ntowards the goal of successfully shipping the product.\n\n\nThis document intends to outline what we believe to be the best\npractices at all the stages related to software development. As\nanything, it isn't written in stone, but rather is what we believe to\nbe sound advice in making software development successful.\n\n\nThe Guiding Principles\n\n\nAt [talPor], we are a multi-disciplinary, multi-location team. We tend\nto work on small teams (generally, by project) which support and\ncollaborate with each other. These guiding principles, which are\nenumerated below, are the core of our philosophy. Embrace them, and\nput them to practice.\n\n\n\n\n\n\nDo not be afraid to make mistakes.\n Mistakes happen. You will\n   over or under-estimate that feature. You will completely\n   misunderstand your client. You will break a build for everyone in\n   your team. You will manage to take down production on a rainy\n   day. \nIt\n happens. And it will happen again. The whole point of\n   this philosophy is to \nminimize\n the number of times that happens.\n\n\n\n\n\n\nAlways try to do your best.\n Even if you have done it a million\n   times, or if it is the first time you get on board on a project,\n   always make solid decisions. Doesn't really matter if you have been\n   in the project from the get go, or you are just joining to hotfix\n   that annoying problem, take that extra time to first \nunderstand\n\n   the requirements, and then \nbuild\n or \nfix\n whatever needs to be\n   fixed as best as you possibly can.\n\n\n\n\n\n\nAsk for help.\n As previously said, we are a small team which is\n   always ready to provide help when needed. Don't be afraid to ask if\n   someone has ever done this or that. Don't be afraid to say you\n   don't know the answer. Don't be afraid to say you don't know how to\n   do something in particular. Likewise, offer your help or advice\n   when you do know what is going on.\n\n\n\n\n\n\nNever take it personally.\n This one is related to #1. It will\n   come the time when that feature branch you poured yourself into\n   will not make it to production. It will happen that your code will\n   take down production, or make the wrong assumptions. It will come\n   the time that you will be told you are doing it wrong. You are not\n   what you code or what you design, and you are not the project you\n   are on.\n\n\n\n\n\n\nWho is this for?\n\n\nThis document is primarily geared towards any talPor employees. It is\nintended to contain glimpses of what we believe to be solid software\nengineering, from the project conception phase up to pivoting and\niterations of a project.\n\n\nAs such, anyone that partakes in any of the phases of software\ndevelopment, can benefit from reading and practicing what is on this\ndocument.\n\n\nHow is this document structured?\n\n\nThe rest of this document is structured trying to follow the common\nsoftware development flow.\n\n\n\n\n\n\nConception\n happens from the minute a new client walks in, or a\n   new internal project is started. Meeting the client, understanding\n   requirements, forming teams, estimating features all happens at\n   this stage.\n\n\n\n\n\n\nDevelopment\n is when the first version of the product is built.\n   Smart technology decisions, good practices, and impeccable communication\n   are key at this stage. This section is also were we go into detail about\n   the methodology we use during projects as well as best practices for development.\n\n\n\n\n\n\nDeployment\n of the project into production. Dealing with\n   showstopper bugs, the 90/10 rule, handling staging and production\n   servers, dealing with bugs on production, continuous integration.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-talpor-philosophy", 
            "text": "", 
            "title": "The talPor Philosophy"
        }, 
        {
            "location": "/#introduction", 
            "text": "Whether you are onboarding on a new project, or just hotfixing a\nproblem in an old one, software development is  hard .  Building software is not only technically hard, but is, like any other\nproblem, highly depend on the human factor. Successfully shaping and\ntaking ideas from just a thought all the way into a successful product\ninvolves tons of work. From the starting point, many variables, like\nyour client, developers, designers, among others, must be aligned\ntowards the goal of successfully shipping the product.  This document intends to outline what we believe to be the best\npractices at all the stages related to software development. As\nanything, it isn't written in stone, but rather is what we believe to\nbe sound advice in making software development successful.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#the-guiding-principles", 
            "text": "At [talPor], we are a multi-disciplinary, multi-location team. We tend\nto work on small teams (generally, by project) which support and\ncollaborate with each other. These guiding principles, which are\nenumerated below, are the core of our philosophy. Embrace them, and\nput them to practice.    Do not be afraid to make mistakes.  Mistakes happen. You will\n   over or under-estimate that feature. You will completely\n   misunderstand your client. You will break a build for everyone in\n   your team. You will manage to take down production on a rainy\n   day.  It  happens. And it will happen again. The whole point of\n   this philosophy is to  minimize  the number of times that happens.    Always try to do your best.  Even if you have done it a million\n   times, or if it is the first time you get on board on a project,\n   always make solid decisions. Doesn't really matter if you have been\n   in the project from the get go, or you are just joining to hotfix\n   that annoying problem, take that extra time to first  understand \n   the requirements, and then  build  or  fix  whatever needs to be\n   fixed as best as you possibly can.    Ask for help.  As previously said, we are a small team which is\n   always ready to provide help when needed. Don't be afraid to ask if\n   someone has ever done this or that. Don't be afraid to say you\n   don't know the answer. Don't be afraid to say you don't know how to\n   do something in particular. Likewise, offer your help or advice\n   when you do know what is going on.    Never take it personally.  This one is related to #1. It will\n   come the time when that feature branch you poured yourself into\n   will not make it to production. It will happen that your code will\n   take down production, or make the wrong assumptions. It will come\n   the time that you will be told you are doing it wrong. You are not\n   what you code or what you design, and you are not the project you\n   are on.", 
            "title": "The Guiding Principles"
        }, 
        {
            "location": "/#who-is-this-for", 
            "text": "This document is primarily geared towards any talPor employees. It is\nintended to contain glimpses of what we believe to be solid software\nengineering, from the project conception phase up to pivoting and\niterations of a project.  As such, anyone that partakes in any of the phases of software\ndevelopment, can benefit from reading and practicing what is on this\ndocument.", 
            "title": "Who is this for?"
        }, 
        {
            "location": "/#how-is-this-document-structured", 
            "text": "The rest of this document is structured trying to follow the common\nsoftware development flow.    Conception  happens from the minute a new client walks in, or a\n   new internal project is started. Meeting the client, understanding\n   requirements, forming teams, estimating features all happens at\n   this stage.    Development  is when the first version of the product is built.\n   Smart technology decisions, good practices, and impeccable communication\n   are key at this stage. This section is also were we go into detail about\n   the methodology we use during projects as well as best practices for development.    Deployment  of the project into production. Dealing with\n   showstopper bugs, the 90/10 rule, handling staging and production\n   servers, dealing with bugs on production, continuous integration.", 
            "title": "How is this document structured?"
        }, 
        {
            "location": "/conception/", 
            "text": "On the project conception phase\n\n\nThe conception phase begins at the moment a new project walks through\nthe door. The main focus in this stage is understanding the\nrequirements of the project, and the results of this whole process is\na set of mockups and estimations that fulfills the requirements.\n\n\nDuring this stage, the team that will be involved in a project is\nbuilt, taking into consideration what is known initially. The idea is\nthat each team member strengths can be used to successfully take the\nproject from zero to production in reasonable time.\n\n\nAt talPor, this process is known as the \ndiscovery\n. During a\ndiscovery, fast paced meetings between the client and the team take\nplace with the goal of defining the requirements and defining what\nwill be part of the \nMVP (Minimum Viable Product)\n. These meetings\nshould be happening as fast as schedule permits.\n\n\nGenerally, clients will want to build every conceivable feature that\nis remotely related to their idea. As such, generally there is a lot\nof noise when you try to figure out what is the real problem the\nclient is trying to solve. At this stage you want to understand and\nisolate what is the big problem at hand, and provide the tools to\nsolve it.\n\n\nAlso remember, at the end of the day, we are also developing the\nclient idea. We are interested in the client to be successful, so we\nwant to be able, at the end of the development process and into the\nproduction stage, to be able to (in)validate the path that has been\nchosen.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nListen to what the client says and want. \nTake notes\n.\n\n\n\n\n\n\nBe polite with your client but very assertive.\n\n\n\n\n\n\nExplain when something is not possible (or extremely hard).\n\n\n\n\n\n\nInvolve everybody, including the client, in the process. Don't take\n  ideas for granted, don't make assumptions, speak up when necessary.\n\n\n\n\n\n\nThe Feedback Loop\n\n\nThe feedback loop is the shape the discovery process takes as meetings\nwith the client take place. When the first meeting with the client\nhappens, it is expected that the client will talk and explain the\nproject to the team, while the team takes notes and asks questions. In\nthis meeting, most of the talk will be done by the client.\n\n\nAfter the first meeting, the team will start shaping up the\nrequirements the client talked about. Possibly, the team will come up\nwith wireframes or mockups, or some other way to visualize it. As the\nnext meeting with the client comes around (which should be as soon as\npossible), roles in the meeting slightly shift.\n\n\nDuring the second meeting, the team will present their mockups to the\nclient. It is expected that the client will have comments, questions\nor simply have more to add to what was already said. Again, the team\ntakes notes and gets the opportunity to ask more questions which help\nsolidify the vision of a project.\n\n\nThe internal work is repeated again, coming up with new visualizations\nof the requirements. As the next meeting comes around, the roles in\nthe meeting shift even more, with the team explaining the vision of\nthe requirements they have, and the client, ideally, aligning even\nfurther with that vision. More comments and questions can be posed by\nthe client, but ideally as every meeting with further developments\nhappen, the client will have less and less to say.\n\n\nThis loop continues, until a united vision between the team and the\nclient is agreed upon.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nPrepare before your client meeting and summarize what happens after\n  it.\n Take the time to do a short \npre-meeting\n with your teammates to\n  have a common understanding and goals in the meeting, and a short\n  \npost-meeting\n once the meeting is over.\n\n\n\n\n\n\nTry to validate your team hypothesis.\n For example, try to propose\n  stuff that is known to work instead of reinventing the wheel.\n\n\n\n\n\n\nUse what is available to you.\n If this is not a new project, ask to\n  see Google Analytics data, or any data that the project has\n  available. Make better hypothesis using this.\n\n\n\n\n\n\nAssume as little as possible.\n If you can't validate, it's just a\n  hunch.\n\n\n\n\n\n\nSometimes, the client don't want to let go of a feature they deem\n  really important. Try to compromise, try to explain why is it not\n  possible. Explain that if that feature makes it into the final\n  vision for the MVP, other features will have to be dropped for now.\n\n\n\n\n\n\nThe whole point of the discovery is to converge on a concrete but\n  not final vision for the project. Sometimes, your client will always\n  have something more to say, if possible listen, if not, remind them\n  that this is a MVP and more time to build other features will always\n  be there afterwards.\n\n\n\n\n\n\nRemind your client there is space for more development after the MVP\n  is done. The point of bounding the reach of the MVP is to be able to\n  \nvalidate as soon as possible\n rather than when multiple months of\n  development have been poured into the wrong hypothesis.\n\n\n\n\n\n\nMockups\n\n\nMockups are one of the deliverables of the discovery process. It\nshould represent a very basic view of the direction the team is taking\nwith the project. During the discovery process, mockups should be used\nto aid the delivery of the vision by the team.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nWhile simple, mockups should be sufficient to represent the vision\n  the project will take. Don't overlook details, but be pragmatic\n  about them.\n\n\n\n\n\n\nCurrently, we use \nBalsamiq Mockups\n to build\n  mockups.\n\n\n\n\n\n\nEstimations\n\n\nEstimations are one of the deliverables of the discovery process. At\ntalPor, we use a system of \nuser stories and story points\n to\nestimate tasks to be done in a project. A user story is a sentence of\nthe form \"As a [actor], I want to [action]\". For example, one possible\nuser story is \"As a user, I want to log in\".\n\n\nEvery single feature that is proposed during the discovery process\nshould be turned into one or several user stories. Consider using\n\nthemes\n to classify user stories. For example, the previous user\nstory could be part of the \naccounts\n theme. \nEvery user story should\nbe estimated using story points.\n\n\nAt talPor we use a Fibonacci schemed story point system. We can assign\nto every task the following story points: 0.5, 1, 2 (a day worth of\nwork), 3, 5, 8, 13, and 20+. We estimate every engineer can perform 10\nstory points a week, as such, assigning 8 to a task is saying it is\nexpected to take less than a week, and 13 more than one week.\n\n\nAssigning story points to a task should be done by the engineering\nteam physically at the same place (or via a video conference if not\npossible). Ideally, each team member should have a set of cards or pieces\nof paper with the possible story point values (0.5, 1, 2, 3, ...) written on them.\n\n\nYou should start by agreeing upon a user story that you all\nestimate to be a 2, and another user story that you all estimate to be a 5.\nThe need for this is to set a baseline for comparison when estimating the\nremaining cards. Once these have been agreed upon, for each user story\nevery team member shows the card with the story points they believe the\nstory will take. If every member estimated the same, then the value is\nrecorded as the user story estimation. In case there was a disagreement,\na \nconsensus needs to be reached\n before an estimation can be recorded\nfor the user story.\n\n\nOnce every user story is estimated, some calculations should be done\nto figure out the expected standard deviation for the user\nstories. There are internal spreadsheets available to do this. Using\nthose calculations, an expected delivery time for all the user stories\ncan be estimated.\n\n\nProjects generally have a time frame. If the expected delivery time\nexceeds the project time frame, then further negotiation is needed\nbetween the team and client, even if a common vision was agreed upon\nby both parties. Common ways to do this include removing user stories\nor changing their scopes or reach.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nYour estimation will probably be wrong.\n Humans are exceptionally\n  bad at estimating time, especially under-estimating. Do your best to\n  keep the estimation as honest and real as possible.\n\n\n\n\n\n\nAccount for testing, deployment, bugfixing and other changes.\n\n  You will not always be building new features in the project. Account\n  for time building tests for the codebase, time spent making sure\n  deployment works, bugfixing or design changes.\n\n\n\n\n\n\nIf you find yourself using big story points for a user story, or\n  needing higher story points, consider splitting your user stories\n  into smaller more manageable user stories.\n\n\n\n\n\n\nKeep your estimations up-to-date in the project's [Trello] board.", 
            "title": "Conception"
        }, 
        {
            "location": "/conception/#on-the-project-conception-phase", 
            "text": "The conception phase begins at the moment a new project walks through\nthe door. The main focus in this stage is understanding the\nrequirements of the project, and the results of this whole process is\na set of mockups and estimations that fulfills the requirements.  During this stage, the team that will be involved in a project is\nbuilt, taking into consideration what is known initially. The idea is\nthat each team member strengths can be used to successfully take the\nproject from zero to production in reasonable time.  At talPor, this process is known as the  discovery . During a\ndiscovery, fast paced meetings between the client and the team take\nplace with the goal of defining the requirements and defining what\nwill be part of the  MVP (Minimum Viable Product) . These meetings\nshould be happening as fast as schedule permits.  Generally, clients will want to build every conceivable feature that\nis remotely related to their idea. As such, generally there is a lot\nof noise when you try to figure out what is the real problem the\nclient is trying to solve. At this stage you want to understand and\nisolate what is the big problem at hand, and provide the tools to\nsolve it.  Also remember, at the end of the day, we are also developing the\nclient idea. We are interested in the client to be successful, so we\nwant to be able, at the end of the development process and into the\nproduction stage, to be able to (in)validate the path that has been\nchosen.  Always keep in mind:    Listen to what the client says and want.  Take notes .    Be polite with your client but very assertive.    Explain when something is not possible (or extremely hard).    Involve everybody, including the client, in the process. Don't take\n  ideas for granted, don't make assumptions, speak up when necessary.    The Feedback Loop  The feedback loop is the shape the discovery process takes as meetings\nwith the client take place. When the first meeting with the client\nhappens, it is expected that the client will talk and explain the\nproject to the team, while the team takes notes and asks questions. In\nthis meeting, most of the talk will be done by the client.  After the first meeting, the team will start shaping up the\nrequirements the client talked about. Possibly, the team will come up\nwith wireframes or mockups, or some other way to visualize it. As the\nnext meeting with the client comes around (which should be as soon as\npossible), roles in the meeting slightly shift.  During the second meeting, the team will present their mockups to the\nclient. It is expected that the client will have comments, questions\nor simply have more to add to what was already said. Again, the team\ntakes notes and gets the opportunity to ask more questions which help\nsolidify the vision of a project.  The internal work is repeated again, coming up with new visualizations\nof the requirements. As the next meeting comes around, the roles in\nthe meeting shift even more, with the team explaining the vision of\nthe requirements they have, and the client, ideally, aligning even\nfurther with that vision. More comments and questions can be posed by\nthe client, but ideally as every meeting with further developments\nhappen, the client will have less and less to say.  This loop continues, until a united vision between the team and the\nclient is agreed upon.  Always keep in mind:    Prepare before your client meeting and summarize what happens after\n  it.  Take the time to do a short  pre-meeting  with your teammates to\n  have a common understanding and goals in the meeting, and a short\n   post-meeting  once the meeting is over.    Try to validate your team hypothesis.  For example, try to propose\n  stuff that is known to work instead of reinventing the wheel.    Use what is available to you.  If this is not a new project, ask to\n  see Google Analytics data, or any data that the project has\n  available. Make better hypothesis using this.    Assume as little as possible.  If you can't validate, it's just a\n  hunch.    Sometimes, the client don't want to let go of a feature they deem\n  really important. Try to compromise, try to explain why is it not\n  possible. Explain that if that feature makes it into the final\n  vision for the MVP, other features will have to be dropped for now.    The whole point of the discovery is to converge on a concrete but\n  not final vision for the project. Sometimes, your client will always\n  have something more to say, if possible listen, if not, remind them\n  that this is a MVP and more time to build other features will always\n  be there afterwards.    Remind your client there is space for more development after the MVP\n  is done. The point of bounding the reach of the MVP is to be able to\n   validate as soon as possible  rather than when multiple months of\n  development have been poured into the wrong hypothesis.    Mockups  Mockups are one of the deliverables of the discovery process. It\nshould represent a very basic view of the direction the team is taking\nwith the project. During the discovery process, mockups should be used\nto aid the delivery of the vision by the team.  Always keep in mind:    While simple, mockups should be sufficient to represent the vision\n  the project will take. Don't overlook details, but be pragmatic\n  about them.    Currently, we use  Balsamiq Mockups  to build\n  mockups.    Estimations  Estimations are one of the deliverables of the discovery process. At\ntalPor, we use a system of  user stories and story points  to\nestimate tasks to be done in a project. A user story is a sentence of\nthe form \"As a [actor], I want to [action]\". For example, one possible\nuser story is \"As a user, I want to log in\".  Every single feature that is proposed during the discovery process\nshould be turned into one or several user stories. Consider using themes  to classify user stories. For example, the previous user\nstory could be part of the  accounts  theme.  Every user story should\nbe estimated using story points.  At talPor we use a Fibonacci schemed story point system. We can assign\nto every task the following story points: 0.5, 1, 2 (a day worth of\nwork), 3, 5, 8, 13, and 20+. We estimate every engineer can perform 10\nstory points a week, as such, assigning 8 to a task is saying it is\nexpected to take less than a week, and 13 more than one week.  Assigning story points to a task should be done by the engineering\nteam physically at the same place (or via a video conference if not\npossible). Ideally, each team member should have a set of cards or pieces\nof paper with the possible story point values (0.5, 1, 2, 3, ...) written on them.  You should start by agreeing upon a user story that you all\nestimate to be a 2, and another user story that you all estimate to be a 5.\nThe need for this is to set a baseline for comparison when estimating the\nremaining cards. Once these have been agreed upon, for each user story\nevery team member shows the card with the story points they believe the\nstory will take. If every member estimated the same, then the value is\nrecorded as the user story estimation. In case there was a disagreement,\na  consensus needs to be reached  before an estimation can be recorded\nfor the user story.  Once every user story is estimated, some calculations should be done\nto figure out the expected standard deviation for the user\nstories. There are internal spreadsheets available to do this. Using\nthose calculations, an expected delivery time for all the user stories\ncan be estimated.  Projects generally have a time frame. If the expected delivery time\nexceeds the project time frame, then further negotiation is needed\nbetween the team and client, even if a common vision was agreed upon\nby both parties. Common ways to do this include removing user stories\nor changing their scopes or reach.  Always keep in mind:    Your estimation will probably be wrong.  Humans are exceptionally\n  bad at estimating time, especially under-estimating. Do your best to\n  keep the estimation as honest and real as possible.    Account for testing, deployment, bugfixing and other changes. \n  You will not always be building new features in the project. Account\n  for time building tests for the codebase, time spent making sure\n  deployment works, bugfixing or design changes.    If you find yourself using big story points for a user story, or\n  needing higher story points, consider splitting your user stories\n  into smaller more manageable user stories.    Keep your estimations up-to-date in the project's [Trello] board.", 
            "title": "On the project conception phase"
        }, 
        {
            "location": "/development/", 
            "text": "Project development phase\n\n\nThe development phase begins immediately after conception, together\nwith design it makes up the core of the software development\nprocess. For software engineers, the development phase is their time\nto shine. In this stage, user stories are scheduled for development on\na week-by-week basis for the engineering team to work on. Initially,\nthe focus is on building the functionality of the MVP, while the design\nteam works in parallel designing the whole user interface and user\nexperience according to the user stories and mockups. Once the design\nteam starts producing designs, those are to be implemented into the final\nproduct that will be delivered.\n\n\nOnboarding\n\n\nRight before starting the development process, take the time to establish\nclear and redundant communication paths between the client and the team. \nIt is\npreferable to over-communicate than to under-communicate.\n\n\nGood communication is the #1 way to avoid overly long meetings and\nlast minute changes of heart. Involve the client, engage and\nlisten. Good communication between the team members avoids bugs and\nproblems down the road. As with the discovery meetings, take time to\nschedule \npre-\n and \npost-meetings\n where you review what was done and\nwhat will be done now.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nUse tools to aid your communication. Set up [Slack] for real time\n  communication with the client, set up [Trello] to track what is being\n  done. Use the integrations between your tools, for example\n  Slack-Trello integration can be useful to notify the client new\n  changes are up.\n\n\n\n\n\n\nSchedule your client meetings. \nBe on time\n. If you are being\n  dilligent about keeping your communication paths open, meetings\n  should be just a summary of what was done and what is going to be\n  worked on during the week.\n\n\n\n\n\n\nAvoid using meetings for testing and bug reports\n. Forward\n  problems to the right communication channels. This helps keep\n  meetings straightforward, and helps you keep track of what needs to\n  be done.\n\n\n\n\n\n\nMethodology\n\n\nFor our development process we use an agile methodology. Our methodology draws\nfrom Scrum and Extreme Programming (XP), both well-known and well-documented\nagile methodologies. Therefore, to get details regarding our practices that\nescape the scope of this handbook, the documentation for these methodologies\nis the place to look.\n\n\nSo, what does using an agile methodology entail? It means we expect project\nrequirements to be constantly evolving and what we developed a week ago can be\nvery far from what we're building for tomorrow. You might be wondering:\n\n\"What the hell? How are you supposed to plan and build software under those\nconditions?\"\n. Well, we do.\n\n\nAgile methodologies were born out of the inability of other methodologies, like\nRUP or Waterfall, to adapt to unavoidable changes that occur while a product\nis being developed. So how do we handle this and keep our clients happy? We\nfollow incremental design guidelines and an iterative development process in\norder to minimize the risks that this constant evolution entails.\n\n\nThere are several techniques and weekly tasks that need to be followed as part\nof talPor's methodology so read on to the \nMethodology\n\nsection for further detail of what needs to be done during a project's life cycle.\n\n\nTechnical standards\n\n\nWe're a tech company that builds products and in order to deliver a great product\nwe need to be writing great code and using the best tools and software for the\njob. Also, in order to share our experience as a team, we need to be on the same\npage as to what software we're using as well as how we're using it. To accomplish\nboth those things we have a set of standards and recommendations that are documented\nin the \nTechnical Standards\n section.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/#project-development-phase", 
            "text": "The development phase begins immediately after conception, together\nwith design it makes up the core of the software development\nprocess. For software engineers, the development phase is their time\nto shine. In this stage, user stories are scheduled for development on\na week-by-week basis for the engineering team to work on. Initially,\nthe focus is on building the functionality of the MVP, while the design\nteam works in parallel designing the whole user interface and user\nexperience according to the user stories and mockups. Once the design\nteam starts producing designs, those are to be implemented into the final\nproduct that will be delivered.  Onboarding  Right before starting the development process, take the time to establish\nclear and redundant communication paths between the client and the team.  It is\npreferable to over-communicate than to under-communicate.  Good communication is the #1 way to avoid overly long meetings and\nlast minute changes of heart. Involve the client, engage and\nlisten. Good communication between the team members avoids bugs and\nproblems down the road. As with the discovery meetings, take time to\nschedule  pre-  and  post-meetings  where you review what was done and\nwhat will be done now.  Always keep in mind:    Use tools to aid your communication. Set up [Slack] for real time\n  communication with the client, set up [Trello] to track what is being\n  done. Use the integrations between your tools, for example\n  Slack-Trello integration can be useful to notify the client new\n  changes are up.    Schedule your client meetings.  Be on time . If you are being\n  dilligent about keeping your communication paths open, meetings\n  should be just a summary of what was done and what is going to be\n  worked on during the week.    Avoid using meetings for testing and bug reports . Forward\n  problems to the right communication channels. This helps keep\n  meetings straightforward, and helps you keep track of what needs to\n  be done.    Methodology  For our development process we use an agile methodology. Our methodology draws\nfrom Scrum and Extreme Programming (XP), both well-known and well-documented\nagile methodologies. Therefore, to get details regarding our practices that\nescape the scope of this handbook, the documentation for these methodologies\nis the place to look.  So, what does using an agile methodology entail? It means we expect project\nrequirements to be constantly evolving and what we developed a week ago can be\nvery far from what we're building for tomorrow. You might be wondering: \"What the hell? How are you supposed to plan and build software under those\nconditions?\" . Well, we do.  Agile methodologies were born out of the inability of other methodologies, like\nRUP or Waterfall, to adapt to unavoidable changes that occur while a product\nis being developed. So how do we handle this and keep our clients happy? We\nfollow incremental design guidelines and an iterative development process in\norder to minimize the risks that this constant evolution entails.  There are several techniques and weekly tasks that need to be followed as part\nof talPor's methodology so read on to the  Methodology \nsection for further detail of what needs to be done during a project's life cycle.  Technical standards  We're a tech company that builds products and in order to deliver a great product\nwe need to be writing great code and using the best tools and software for the\njob. Also, in order to share our experience as a team, we need to be on the same\npage as to what software we're using as well as how we're using it. To accomplish\nboth those things we have a set of standards and recommendations that are documented\nin the  Technical Standards  section.", 
            "title": "Project development phase"
        }, 
        {
            "location": "/development/methodology/", 
            "text": "\ufeffMethodology\n\n\nWhat are you working on?\n\n\nUse and keep your communication paths up-to-date with your team and\nclient. Especially, constantly update your Trello lists. Once you start\nworking on a new card, move it to \nDoing\n. Once you complete it, move\nit to \nDone\n. As soon as it is available for testing on the staging\nserver, move it to \nIn Testing\n.\n\n\nFollow work that is being done by your teammates closely. It is often\nuseful to read commit messages and check commit changes. Make sure you\nare on top of the feedback your client is giving you through all the\nchannels you have established. If a task is rejected, handle the\nfeedback promptly. If a new bug is found, handle the feedback or\ncreate a new card and put it on the \nBacklog\n.\n\n\nKeep communication up-to-date.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/methodology/#methodology", 
            "text": "What are you working on?  Use and keep your communication paths up-to-date with your team and\nclient. Especially, constantly update your Trello lists. Once you start\nworking on a new card, move it to  Doing . Once you complete it, move\nit to  Done . As soon as it is available for testing on the staging\nserver, move it to  In Testing .  Follow work that is being done by your teammates closely. It is often\nuseful to read commit messages and check commit changes. Make sure you\nare on top of the feedback your client is giving you through all the\nchannels you have established. If a task is rejected, handle the\nfeedback promptly. If a new bug is found, handle the feedback or\ncreate a new card and put it on the  Backlog .  Keep communication up-to-date.", 
            "title": "\ufeffMethodology"
        }, 
        {
            "location": "/development/methodology/post-mortem/", 
            "text": "The process\n\n\nAt the end of a project cycle or when somebody gets out of the project, we run a \nPost-Mortem\n or \nLessons learned\n process. \n\n\nThe \nPost-mortem\n is a valuable tool to ensure continuous improvement for a software development team. Although its name seems forbidding it's just a process to assess how a project went. Some people prefer to call it \nRetrospective\n instead because \nPost-Mortem\n seems to be a negative term that implies the death of a project.\n\n\nIn our case, we will stick to \nPost-Mortem\n or \nLessons learned\n since we actually run several retrospectives during the project lifespan and they have different approaches and goals than the ones being described here.\n\n\nIn talPor \nPost-Mortems\n are carried out in two phases. The first one is individual and consists in filling in a \nPost-Mortem report\n. Each project member provides his own reflection and assessment about the overall project arc in a way that we can discover what went well and whatf could be done better next time. The ultimate goal is \"lessons learned\" \u2014 a set of actionable ideas for improving the next project.  \n\n\nThe second phase consist in a \nPost-Mortem meeting\n, this is where the different reports outcomes are discussed and conclusions and \"lessons learned\" are drawn. \n\n\nThere are two different scenarios where the \nPost-Mortems\n are applied:\n\n\n\n\nA team member gets out of the project.\n\n\nThe project cycle ends or the project is finished.\n\n\n\n\nFor each scenario there is a different course of action. If a \nmember leaves the team\n his post-mortem report will be evaluated in the following \nRetrospective meeting\n. In this case, the retrospective meeting will consists on the post-mortem evaluation as first task, from which the outcomes will be used as input for the current retrospective where the ex-member is not bounded to participate.\n\n\nIn the case where the \nproject cycle ends or the project is finished\n we organize a \nPost-Mortem meeting\n as described before.\n\n\nPost-mortem report\n\n\nThe purpose of the Project Post-Mortem Report is to record, in detail, the specific project activities that were most effective and those that require adjustments for future projects. The objective of this report is to inform future projsect teams of important lessons learned during the project (i.e. obstacles, challenges, successes, what could be done differently next time, etc.). \n\n\nIn talPor we have a custom post-mortem report template that is used to gather this information. This template is sent as a google questionnaire and its answers are stored in a google spreadsheet. \n\n\n\n\nPost-mortem meeting", 
            "title": "PostMortem"
        }, 
        {
            "location": "/development/methodology/post-mortem/#the-process", 
            "text": "At the end of a project cycle or when somebody gets out of the project, we run a  Post-Mortem  or  Lessons learned  process.   The  Post-mortem  is a valuable tool to ensure continuous improvement for a software development team. Although its name seems forbidding it's just a process to assess how a project went. Some people prefer to call it  Retrospective  instead because  Post-Mortem  seems to be a negative term that implies the death of a project.  In our case, we will stick to  Post-Mortem  or  Lessons learned  since we actually run several retrospectives during the project lifespan and they have different approaches and goals than the ones being described here.  In talPor  Post-Mortems  are carried out in two phases. The first one is individual and consists in filling in a  Post-Mortem report . Each project member provides his own reflection and assessment about the overall project arc in a way that we can discover what went well and whatf could be done better next time. The ultimate goal is \"lessons learned\" \u2014 a set of actionable ideas for improving the next project.    The second phase consist in a  Post-Mortem meeting , this is where the different reports outcomes are discussed and conclusions and \"lessons learned\" are drawn.   There are two different scenarios where the  Post-Mortems  are applied:   A team member gets out of the project.  The project cycle ends or the project is finished.   For each scenario there is a different course of action. If a  member leaves the team  his post-mortem report will be evaluated in the following  Retrospective meeting . In this case, the retrospective meeting will consists on the post-mortem evaluation as first task, from which the outcomes will be used as input for the current retrospective where the ex-member is not bounded to participate.  In the case where the  project cycle ends or the project is finished  we organize a  Post-Mortem meeting  as described before.", 
            "title": "The process"
        }, 
        {
            "location": "/development/methodology/post-mortem/#post-mortem-report", 
            "text": "The purpose of the Project Post-Mortem Report is to record, in detail, the specific project activities that were most effective and those that require adjustments for future projects. The objective of this report is to inform future projsect teams of important lessons learned during the project (i.e. obstacles, challenges, successes, what could be done differently next time, etc.).   In talPor we have a custom post-mortem report template that is used to gather this information. This template is sent as a google questionnaire and its answers are stored in a google spreadsheet.", 
            "title": "Post-mortem report"
        }, 
        {
            "location": "/development/methodology/post-mortem/#post-mortem-meeting", 
            "text": "", 
            "title": "Post-mortem meeting"
        }, 
        {
            "location": "/development/methodology/trello/", 
            "text": "\ufeffTrello\n\n\nThis section will define how we should be using Trello in our projects.\n\n\nNaming of Cards (US, Tasks):\n\n\nThe name of the card should contain a user story that somebody will have to do. This task can be obtained from the user stories or by a requirement that the client needs.\n\n\nThe name of the card should be short but it needs to explain what is needed to be done, if there is some extra information that is needed to fully understand the task it should be written in the description of the card. The same way if there is document that is related to the task it should be attached to the card so the person responsible of making the task can easy access to it.\n\n\nUse of Trello in Weekly Meetings:\n\n\nTrello is the main way in which we can communicate with the client about what we are currently doing, what we did and what we are going to do in the future. This means that that we need to keep it up to date and inform the client that he can keep an eye on the project at any moment just by looking at the cards on Trello.\n\n\nBefore every meeting we need to watch what is in trello and what is the status of every card so we can give a correct information about the project to the client. Use trello to write the agenda of the meeting, in this way everybody can see what have happen in the previous meetings in an easy way. Also write in the agenda thing that come out in the meeting as thing that need to be done that aren't necessary a task.\n\n\nDuring the meeting you need to inform the client about the status of Trello that should be the status of the project. Let the client ask questions about the cards and answer any doubts that come out. After the meeting you need to update Trello to reflect what is going to be done in the next iteration and estimate the corresponding cards.\n\n\nLists and meaning of lists:\n\n\n\n\n\n\nBacklog:\n\nHere should be every task that define the project. If a task is not in the backlog (or any other list) it doesn't exist. Any idea, any \"nice to have\" feature, everything that should be included in the system at any point in the development should be there so everybody can track what are the things that is left to complete the project. The bugs that are found in the project should be created in this list and must be marked with a \nBUG\n label.\n\n\n\n\n\n\nToDo:\n\nIn this list should be the tasks that are going to be done in the current iteration. Those tasks should have been estimated in order to be sure that the iteration can be completed on time.\n\n\n\n\n\n\nDoing:\n\nAs soon as you begin to work in a task you should move it from \"ToDo\" to \"Doing\" this helps the team, and the client, to know what is the current status of the iteration and in what things the team is working.\n\n\n\n\n\n\nPending Review (optional, to be reviewed by other dev):\n\nThe general idea behind this list is to add a step in the quality of the software that we are building. There are some things that the client can't or don't want to test, this things should be tested by someone different of the developer of the task. This is optional, it depends if the team is bigger than one developer and if there is time planned in the iteration to do this tests.\n\n\n\n\n\n\nTo be tested (to be reviewed and approved by client):\n\nThis tests are known as \"Acceptance Tests\", the client is the only one who knows what he really wants so it depends of him if the feature that we build satisfies his needs. Sometimes the client doesn't want to do the tests in the test server, but is really necessary to make him understands that this is the only way that we can be sure that we are building the right product.\n\n\n\n\n\n\nApproved (Ready for Deploy):\n\nThe client let the team knows that the card is approved by moving it from \"To be tested\" to \"Approved\". Only the client can move the cards to this list (Unless there is a previous agreement that another person can do it). The cards on this list can be deployed into production when the client needed to.\n\n\na- Code is implemented and working.\n\n\nb- Tests are written and passes.\n\n\nc- Code is live in the development (or test) server.\n\n\n\n\n\n\nDone:\n\nHere should be the cards that are approved by the client and that are already in the production server. After the client approves the card, the person responsible of making the deploy into production should put the card in this list as soon as he finish the deploy (The features should be \"\nsmoke tested\n\" to be sure that everything is OK).\n\n\na- Task was in Approved (ready for deploy).\n\n\nb- Acceptance test have been carried out by the client.\n\n\nc- Code is in production environment.\n\n\n\n\n\n\nAgenda:\n\nIn this list every card represents a meeting, in those cards is the information about the points that were discussed in the meeting. The name of the card is the date in which the meeting occurs.\nUse a \ntodo list\n to show the points to be discussed. Use the description to annotate any information relevant about the points of the meetings.\nYou can attach documents or make comments about the meeting using the corresponding feature in Trello.\n\n\n\n\n\n\nRemember that a tool is only useful if the anyone uses it. Due to the fact that we are not in the same place we strongly depend of this kind of tools to be able to do our job in a good way. So do not hesitate to bring new insights about how we can improve the way we use Trello or if there is another tool that can replace this and make our life easier.", 
            "title": "Trello"
        }, 
        {
            "location": "/development/methodology/trello/#trello", 
            "text": "This section will define how we should be using Trello in our projects.  Naming of Cards (US, Tasks):  The name of the card should contain a user story that somebody will have to do. This task can be obtained from the user stories or by a requirement that the client needs.  The name of the card should be short but it needs to explain what is needed to be done, if there is some extra information that is needed to fully understand the task it should be written in the description of the card. The same way if there is document that is related to the task it should be attached to the card so the person responsible of making the task can easy access to it.  Use of Trello in Weekly Meetings:  Trello is the main way in which we can communicate with the client about what we are currently doing, what we did and what we are going to do in the future. This means that that we need to keep it up to date and inform the client that he can keep an eye on the project at any moment just by looking at the cards on Trello.  Before every meeting we need to watch what is in trello and what is the status of every card so we can give a correct information about the project to the client. Use trello to write the agenda of the meeting, in this way everybody can see what have happen in the previous meetings in an easy way. Also write in the agenda thing that come out in the meeting as thing that need to be done that aren't necessary a task.  During the meeting you need to inform the client about the status of Trello that should be the status of the project. Let the client ask questions about the cards and answer any doubts that come out. After the meeting you need to update Trello to reflect what is going to be done in the next iteration and estimate the corresponding cards.  Lists and meaning of lists:    Backlog: \nHere should be every task that define the project. If a task is not in the backlog (or any other list) it doesn't exist. Any idea, any \"nice to have\" feature, everything that should be included in the system at any point in the development should be there so everybody can track what are the things that is left to complete the project. The bugs that are found in the project should be created in this list and must be marked with a  BUG  label.    ToDo: \nIn this list should be the tasks that are going to be done in the current iteration. Those tasks should have been estimated in order to be sure that the iteration can be completed on time.    Doing: \nAs soon as you begin to work in a task you should move it from \"ToDo\" to \"Doing\" this helps the team, and the client, to know what is the current status of the iteration and in what things the team is working.    Pending Review (optional, to be reviewed by other dev): \nThe general idea behind this list is to add a step in the quality of the software that we are building. There are some things that the client can't or don't want to test, this things should be tested by someone different of the developer of the task. This is optional, it depends if the team is bigger than one developer and if there is time planned in the iteration to do this tests.    To be tested (to be reviewed and approved by client): \nThis tests are known as \"Acceptance Tests\", the client is the only one who knows what he really wants so it depends of him if the feature that we build satisfies his needs. Sometimes the client doesn't want to do the tests in the test server, but is really necessary to make him understands that this is the only way that we can be sure that we are building the right product.    Approved (Ready for Deploy): \nThe client let the team knows that the card is approved by moving it from \"To be tested\" to \"Approved\". Only the client can move the cards to this list (Unless there is a previous agreement that another person can do it). The cards on this list can be deployed into production when the client needed to.  a- Code is implemented and working.  b- Tests are written and passes.  c- Code is live in the development (or test) server.    Done: \nHere should be the cards that are approved by the client and that are already in the production server. After the client approves the card, the person responsible of making the deploy into production should put the card in this list as soon as he finish the deploy (The features should be \" smoke tested \" to be sure that everything is OK).  a- Task was in Approved (ready for deploy).  b- Acceptance test have been carried out by the client.  c- Code is in production environment.    Agenda: \nIn this list every card represents a meeting, in those cards is the information about the points that were discussed in the meeting. The name of the card is the date in which the meeting occurs.\nUse a  todo list  to show the points to be discussed. Use the description to annotate any information relevant about the points of the meetings.\nYou can attach documents or make comments about the meeting using the corresponding feature in Trello.    Remember that a tool is only useful if the anyone uses it. Due to the fact that we are not in the same place we strongly depend of this kind of tools to be able to do our job in a good way. So do not hesitate to bring new insights about how we can improve the way we use Trello or if there is another tool that can replace this and make our life easier.", 
            "title": "\ufeffTrello"
        }, 
        {
            "location": "/development/methodology/done/", 
            "text": "Definition of done\n\n\nThe Definition of done is a concept extracted from the Agile Scrum methodology, it's crucial to a highly functioning agile team. It's defined as a set of criteria or checklist that should be met before a feature (usually a task or a User Story) is considered \nDone\n. With this in mind, everyone that is involved with the team will heave a common understanding of \"what's done\". It should be taken into account that a feature should be considered done when it is a \"potentially shippable\" feature or it's ready to be released.\n\n\nCurrently, we use the following criteria to specify if a feature is done:\n\n\n\n\nThe code for the featured was produced.\n\n\nTests written and passing.\n\n\nThe code is commited and pushed to the development repository.\n\n\nThe code is live in the development server.\n\n\nAcceptance tests have been carried out by the client.\n\n\nCode is merged and pushed into Production environment.\n\n\nCode is live into production environment.\n\n\n\n\n\n\nEvery task or feature must comply with the definition of done before consider it finished!", 
            "title": "Done"
        }, 
        {
            "location": "/development/methodology/done/#definition-of-done", 
            "text": "The Definition of done is a concept extracted from the Agile Scrum methodology, it's crucial to a highly functioning agile team. It's defined as a set of criteria or checklist that should be met before a feature (usually a task or a User Story) is considered  Done . With this in mind, everyone that is involved with the team will heave a common understanding of \"what's done\". It should be taken into account that a feature should be considered done when it is a \"potentially shippable\" feature or it's ready to be released.  Currently, we use the following criteria to specify if a feature is done:   The code for the featured was produced.  Tests written and passing.  The code is commited and pushed to the development repository.  The code is live in the development server.  Acceptance tests have been carried out by the client.  Code is merged and pushed into Production environment.  Code is live into production environment.    Every task or feature must comply with the definition of done before consider it finished!", 
            "title": "Definition of done"
        }, 
        {
            "location": "/development/tech/", 
            "text": "Introduction\n\n\nThis is just a dummy text", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/tech/#introduction", 
            "text": "This is just a dummy text", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/tech/code-reviews/", 
            "text": "Code Reviews\n\n\nCode reviews are what happens when another person looks at code you\nwant to commit or have already commited. The main reason to have code\nreviews is aid \ncode maintainability and catch problems early\n. In\nsmall teams, it ensures that at least two pair of eyes are familiar\nwith every bit of the codebase.\n\n\nAt the moment, code reviews happen on a request basis. We follow a\n\npre-commit\n, or \npre-push\n philosophy. When you want a code review,\nyou can either request it to one of your team members, or request it\nto another coworker. Once your code is approved by your reviewers, you\ncan proceed to merge your code with \nmaster\n.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nIt's easier (and faster) to request a code review on small changes\n  (less than 100 lines) than on a huge feature (over 1000\n  lines). \nPush early, and push often\n. If you anticipate a big\n  feature which you want to have code reviewed, start requesting code\n  reviews as soon as possible and work on them incrementally.\n\n\n\n\n\n\nPre-review your code.\n Everybody's time is valuable. Don't\n  request code reviews on code that doesn't follow code conventions,\n  lacks testing, or is sloppy. As a rule of thumb, ask yourself if you\n  would accept your code if you were the reviewer.\n\n\n\n\n\n\nIf you are reviewing code, handle requests promptly. If you don't\n  understand something stop early and ask for clarifications (either a\n  rewrite of that chunk, or better comment structure). \nDon't reject\n  code because you would have done it differently\n. The main purpose\n  of code reviews is to have \nmaintainable code\n.\n\n\n\n\n\n\nIf a reviewer and a reviewee can't agree over a point, bring a third\n  party (another reviewer) to mediate.", 
            "title": "Code Reviews"
        }, 
        {
            "location": "/development/tech/coding-style/", 
            "text": "Style\n\n\nWhatever your technology stack, write code as idiomatically as you\ncan. Dive into your technology stack code style, follow their style,\nand avoid making one sided decisions. As a common rule of thumb, when\nyou want to do something non-idiomatic, you should be able to first\nconvince a teddy bear and then convince a team member.\n\n\nIf you need to define code style for your project (i.e. we inherited a\ncode base), document it and follow it religiously.\n\n\nOver anything, \nemphasize clean code and readability\n. Use comments\nto explain non obvious code paths. \nDon't be clever\n. Don't over\noptimize for the 1% case, think of the 99% case. If the 1% case\nbecomes a reality, you will be thankful you didn't implement the\noverly complicated, obfuscated option but the easy to follow and to\nthe point option.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nMany languages have a style guide. For example, Python has\n  \nPEP-8\n.\n\n\n\n\n\n\nMany frameworks also have a style guide. For example, Django has its\n  \nCoding Style guidelines\n.\n\n\n\n\n\n\nThere are many community-driven and company-driven efforts to define\n  good style. We enjoy following AirBnB's\n  \nJavaScript Coding Style\n. Google\n  also maintains a repository of style guides for their C++, Python,\n  Angular projects, among others.\n\n\n\n\n\n\nWhen no obvious choice can be made regarding style, select a style\n  guide by consensus, and follow it religiously.\n\n\n\n\n\n\nUse linters. Set them up to follow the agreed upon code style in\n  your project. Add configuration files to your Git repositories if\n  necessary.", 
            "title": "Coding Style"
        }, 
        {
            "location": "/development/tech/source-control/", 
            "text": "Source Control\n\n\nFrom the get go, use version control. This is not negotiable. At\ntalPor we use [Git] exclusively. For open source code, we publish at\n[GitHub] and for everything else we use internal Git repositories.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nDon't rewrite public story!\n Bad stuff happens when you do that,\n    kittens die. Just don't do it.\n\n\n\n\n\n\nTry to make your commits as atomic as possible. If you feel like you\n  have many commits that don't quite work up to a feature (which you\n  have not yet pushed), you can squash them with a rebase.\n\n\n\n\n\n\nFollow \nGit Flow\n. However, we keep master as develop, and production as master. Use feature and hotfix branches.\n\n\n\n\n\n\nWrite good commit messages. Use a good headline and, if needed,\n  follow it by further details about the commit.\n\n\n\n\n\n\nCherish the existence of \ncherry-pick\n and \nbisect\n. Learn how and when\n  to use \nrebase\n and \nreset\n.", 
            "title": "Source Control"
        }, 
        {
            "location": "/development/tech/hotfixes/", 
            "text": "Hotfixes\n\n\nThere are several ways to hotfix problems that can happen in\n\nproduction\n. If the problem is already fixed on \nmaster\n, the easiest\nway is to backport the changes. This can be done cherry-picking the\ncommits that fixes the problem (you are making atomic commits, right?)\n\n\nHowever, sometimes problems only happen or affect \nproduction\n, in\nthis case, you will need to track down the problem and prepare a\nhotfix branch. When you are done fixing the problem, make sure you\nmerge against production.\n\n\nAlways keep in mind:\n\n\n\n\nWhen hotfixing a problem, your tests should pass afterwards.\n\n\nIf new tests are needed, add them to your hotfix branch.\n\n\nUse \ngit cherry-pick -n\n to review the changes you are\n  cherry-picking before commiting them into your current branch.", 
            "title": "Hotfixes"
        }, 
        {
            "location": "/development/tech/tech-stack/", 
            "text": "Technology Stack\n\n\nChoosing the project technology stack is one of the most important and\nlasting decisions of a project. It's almost cruel that such an\nimportant decision has to be made so early in a project life when so\nmany unknowns remain. When selecting the project technology stack,\nmany factors have to be balanced:\n\n\n\n\nStable tools with strong ecosystems and communities.\n\n\nTools which helps us develop fast, and iterate quickly.\n\n\nTools that will make us happy.\n\n\n\n\nMany times is easy to select the hip technology for a project that\nactually requires something radically different, and boring. Selecting\nthe technology stack is a lasting decision that should be \nagreed\nupon\n by the team members.\n\n\nThe following subsections list some of the common choices we have made\nat talPor, and some of the things to look out for.\n\n\nWeb apps\n\n\nWe are primarily a [Python] shop. We generally use [Django] for our\nprojects, although we have successfully used [Flask] for smaller\nprojects. Additionally, we have dipped our toes in the [Node.js] and\n[Rails] world with varying levels of success.\n\n\nWe prefer Python and Django on the backend because there are no\nsurprises. There is no magic, there are no strongly held opinions but\nrather a set of conventions to follow.\n\n\nOn the frontend, we use plain Javascript. We generally work on top of\na framework. We have used [Angular], [Backbone], and [React] in the\npast. Styling is generally done using a combination of [SCSS] and\n[Compass].\n\n\nAlways keep in mind:\n\n\n\n\n\n\nUse starting skeletons for your projects. For Django we have found a\n  lot of success using\n  \nCookicutter Django\n\n  and for Javascript we have enjoyed using\n  \nYeoman Generators\n.\n\n\n\n\n\n\nBe pragmatic.\n Choose the right tool for the job.\n\n\n\n\n\n\nMobile apps\n\n\nMake the pragmatic choice. While the experience is always better on\nnative applications over hybrid applications, sometimes the choice has\nto be made in the interest of development time and resources.\n\n\nAt talPor we have taken on projects that were built on top of\n\nPhoneGap\n and\n\nCordova\n with great results.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nSelect with your current project in mind. If your project needs\n  access to the latest iOS or Android features which have not landed\n  yet on PhoneGap, maybe going native is the best choice.\n\n\n\n\n\n\nFrom a designer point-of-view, designing for Android and iOS are\n  completely different stories. From screen size to the expected user\n  experience, it's all different. Keep this in mind when you decide to\n  go hybrid route.\n\n\n\n\n\n\nDatabases\n\n\nWe are strongly biased towards using\n\nPostgres\n for every new project. There\nare some up and coming NoSQL stores, like Mongo, but we deem them a\nlittle too immature for production.\n\n\nHowever, we love and use \nRedis\n as a K-V store,\ngenerally for caching and the backend for job queues.\n\n\nTooling\n\n\nChoose tools that help you during all the project stages. Your tools\nshould help you while you are developing by providing a good\ndevelopment environment. Your tools should help you make the\ntransition from local to staging and production as painlessly as\npossible.\n\n\nWe primarily use \nFabric\n, on top of the\ncommon system tools we already have available. We also enjoy using\n\nDocker\n to aid environment\nreproducibility. Other great tools are \nGrunt\n\nand \nGulp\n.\n\n\nServices\n\n\nThere are several services that solve many common problems. Don't be\nafraid to use them if they save considerable amount of development\ntime. For example, \nMandrill\n solves the\nproblem of transactional email beautifully with almost no overhead in\nintegration with the existing codebase.\n\n\nAlways keep in mind:\n\n\n\n\nConsider using services that fix non mission critical parts of your\n  project. Evaluate them, and use them if they shorten your\n  development time.", 
            "title": "Tech Stack"
        }, 
        {
            "location": "/development/tech/testing/", 
            "text": "Testing\n\n\nWe strive for 100% testing coverage. Write tests religiously for your\ncode. Test both your backend and frontend, your logic, and common code\npaths. Test for invalid inputs, and malicious inputs. \nTry to break\nyour code\n. It is a lot better if you break it locally, rather than\non production.\n\n\nWhile we are not strongly opinionated on the approach you take (TDD?\nBDD? Red-Green-Refactor?), your codebase should be tested\nagainst. Prefer throughly tested libraries, frameworks and apps over\npoorly tested ones.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nGood testing means shiping working code. \nBe religious about\n  testing your codebase.\n\n\n\n\n\n\nNo testing or poor, sloppy testing will result in bad code\nreviews. Respect your teammates time, write good tests.\n\n\n\n\n\n\nTesting is central to our continuous integration system. Lacking\n  tests means that we won't be able to catch regressions or problems\n  automatically.", 
            "title": "Testing"
        }, 
        {
            "location": "/development/tech/staging/", 
            "text": "Staging\n\n\nStaging (also known as development) is the environment where the\nclient can test the latest changes. Ideally, it is as similar to\nproduction as possible. Setting up a staging server should be a\nimmediate priority as soon as the development phase starts.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nKeeping staging up-to-date aids communication with your client\n. Bugs\n  and issues can be found faster, and dealt with on a timely fashion.\n\n\n\n\n\n\nStaging should always pass all tests!\n Everything on staging is a\n  \ncandidate\n release of your project. Treat this environment seriously:\n  as \nfew\n  bugs as possible should make it here.\n\n\n\n\n\n\nTo help automatically keep track of the previous point, we have\n  continuous integration/deployment tools set up in place. Read up on\n  the deployment phase for more advice.", 
            "title": "Staging"
        }, 
        {
            "location": "/development/tech/security/", 
            "text": "Security\n\n\nWhatever your project or application is, take a minute to understand\nthat what you are building will eventually have to deal with malicious\ninput and carefully crafted exploits. \nExpect the best, but prepare\nfor the worse.\n Test for malicious inputs, understand common attack\nvectors (XSS, CSRF, SQL Injections, man in the middle, ...) and\nmitigate them. Make sure you are \nalways\n testing users for the right\npermissions when trying to do something.\n\n\nUnderstand that data in production is extremely valuable, for you,\nyour client and your client's clients. \nMake scheduled backups and\nstore them off-site.\n\n\nUse SSL when dealing with sensitive information.\n Avoid storing\ncredit cards, or other sensitive information, and if you do, read on\nhow to do it \nsecurely\n. If you are processing payments, consider\nusing established carriers, like [Stripe].\n\n\nStay on top of CVEs and security releases related to your stack. This\nincludes system wide exploits related to your OS and libraries, and\nmaking sure your framework is running on the latest security release.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nSecurity is a process, not a result.\n Plan ahead, dip your toes\n  on the attack vectors, learn to mitigate them.\n\n\n\n\n\n\nFrameworks like Django offer many built-in security provisions. Use\n  them when possible.\n\n\n\n\n\n\nFollow sites which track security releases. Our internal\n  communication system is generally updated when a new vulnerability\n  or security release of common software in our stack is released.\n\n\n\n\n\n\nDon't roll out your own authenticating system.\n But if you manage\n  to convince anyone that this is a good idea, please use strong,\n  salted, one way ciphers to store user passwords.", 
            "title": "Security"
        }, 
        {
            "location": "/development/tech/provisioning/", 
            "text": "Provisioning and Reproducibility\n\n\nSpend time figuring out how to make the different environments in your\nproject easily reproducible. Getting someone on-board on the project\nshould be relatively fast and easy. Adding a new server should also be\nrelatively painless. Keep clear documentation on how to install a\ndevelopment environment and how to perform a staging and production\ndeploy.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nUse your technology stack dependency managers. For example, if you\n  are using python use [pip].\n\n\n\n\n\n\nThere are several up and coming projects that handle reproducible\n  environments. At talPor, we have successfully used [Vagrant] and\n  [Docker] in the past.\n\n\n\n\n\n\nTry to make your local environment as close to staging as possible\n  and staging as close to production as possible.\n\n\n\n\n\n\nBe pragmatic about the previous point. You don't need a load\n  balancer to run your local setup.\n\n\n\n\n\n\nRead on the deployment phase for more advice.", 
            "title": "Provisioning"
        }, 
        {
            "location": "/deployment/", 
            "text": "Deployment phase\n\n\nA deploy is when you push your local changes to either the\nstaging/development server or the production server. It doesn't just\nhappen just the once when everything is done, but it's an event that\nhappens regularly, specially when you are pushing changes from local\nto staging. When you push to production you should take extra care\nbecause you might be dealing with real data from your client.\n\n\nAs a rule of thumb, we generally use AWS for all our servers since it\nprovides the highest level of flexibility and scalability you might\npossibly need.\n\n\nThe Checklist\n\n\nThis checklist is a list of stuff to make sure you are doing (or not\nand why) when setting up or deploying to a server.\n\n\n\n\n\n\nMake sure you disable password logins through SSH. \nEnable public\n  key authentication only\n. Don't change SSH server port from 22 to\n  anything else: \nSecurity by obfuscation is not security.\n\n\n\n\n\n\nUse \nsudo\n and use a good password for both your public key and\n  your account.\n\n\n\n\n\n\nSetup your firewall. Generally you'll want to block everything\n  except ports 22 (SSH), 80 (HTTP) and 443 (HTTPS).\n\n\n\n\n\n\nSetup NGINX as a reverse proxy to your application server.\n\n\n\n\n\n\nProduction should always use a trusted HTTPS certificate. Make sure\n  to get it and set it up.\n\n\n\n\n\n\nRedis is a sweet piece of software. It's so good and versatile that\n  you can use it from a cache backend to a job queue backend. Figure\n  out if you need it in your stack and set it up.\n\n\n\n\n\n\nMake sure we do not leak secrets. \nMake sure that if an API key is\n  accessible by untrusted agents then it is a public key\n. Don't\n  version control secrets. \nUse environment variables to store secret\n  keys.\n\n\n\n\n\n\nSetup automatic backups for production.\n Backup both the\n  database, and user generated content and store it \noffsite.\n\n\n\n\n\n\nLog everything. Read on Logging \n Errors below.\n\n\n\n\n\n\nAutomate your usual deploy process. We suggest using Fabric for\n  this.\n\n\n\n\n\n\nProvisioning\n\n\nWe have a set of Salt states to help with provisioning servers with\nsecure defaults. Don't be afraid to ask for them. There's an ongoing\ninternal effort to move application servers into isolated containers\n(e.g. using Docker). If that sounds interesting, don't be afraid to\nask about that either. Many of our tools, for example our CI pipeline,\nis built around the assumption that you are using Docker, so it might\nbe a good idea to use Docker from the get go.\n\n\nContinuous Integration\n\n\nRead on \nContinuous Integration at talPor\n.\n\n\nErrors and Logging\n\n\nAs a general rule of thumb, log everything. Log errors and\nnotices. Use your stack standard way to do this, \ndon't just spill\nprint statements all over the place.\n If you are doing something\ncritical, like handling payments, make sure you log the transaction\nonce on a log file and once on your database.\n\n\nWe internally use sentry for error logging and notification. Setup a\ndifferent DSN for each of your servers and respond to errors swiftly.", 
            "title": "Deployment"
        }, 
        {
            "location": "/deployment/#deployment-phase", 
            "text": "A deploy is when you push your local changes to either the\nstaging/development server or the production server. It doesn't just\nhappen just the once when everything is done, but it's an event that\nhappens regularly, specially when you are pushing changes from local\nto staging. When you push to production you should take extra care\nbecause you might be dealing with real data from your client.  As a rule of thumb, we generally use AWS for all our servers since it\nprovides the highest level of flexibility and scalability you might\npossibly need.  The Checklist  This checklist is a list of stuff to make sure you are doing (or not\nand why) when setting up or deploying to a server.    Make sure you disable password logins through SSH.  Enable public\n  key authentication only . Don't change SSH server port from 22 to\n  anything else:  Security by obfuscation is not security.    Use  sudo  and use a good password for both your public key and\n  your account.    Setup your firewall. Generally you'll want to block everything\n  except ports 22 (SSH), 80 (HTTP) and 443 (HTTPS).    Setup NGINX as a reverse proxy to your application server.    Production should always use a trusted HTTPS certificate. Make sure\n  to get it and set it up.    Redis is a sweet piece of software. It's so good and versatile that\n  you can use it from a cache backend to a job queue backend. Figure\n  out if you need it in your stack and set it up.    Make sure we do not leak secrets.  Make sure that if an API key is\n  accessible by untrusted agents then it is a public key . Don't\n  version control secrets.  Use environment variables to store secret\n  keys.    Setup automatic backups for production.  Backup both the\n  database, and user generated content and store it  offsite.    Log everything. Read on Logging   Errors below.    Automate your usual deploy process. We suggest using Fabric for\n  this.    Provisioning  We have a set of Salt states to help with provisioning servers with\nsecure defaults. Don't be afraid to ask for them. There's an ongoing\ninternal effort to move application servers into isolated containers\n(e.g. using Docker). If that sounds interesting, don't be afraid to\nask about that either. Many of our tools, for example our CI pipeline,\nis built around the assumption that you are using Docker, so it might\nbe a good idea to use Docker from the get go.  Continuous Integration  Read on  Continuous Integration at talPor .  Errors and Logging  As a general rule of thumb, log everything. Log errors and\nnotices. Use your stack standard way to do this,  don't just spill\nprint statements all over the place.  If you are doing something\ncritical, like handling payments, make sure you log the transaction\nonce on a log file and once on your database.  We internally use sentry for error logging and notification. Setup a\ndifferent DSN for each of your servers and respond to errors swiftly.", 
            "title": "Deployment phase"
        }, 
        {
            "location": "/wrapup/", 
            "text": "Goodbye\n\n\ntalPor\n strongly believes that you build the company you want to work\nfor. As such, we are constantly iterating, testing new hypothesis, and\nvalidating. This document is always-changing, and we welcome thoughts,\nideas, and suggestions to improve our process.", 
            "title": "Wrap-up"
        }, 
        {
            "location": "/wrapup/#goodbye", 
            "text": "talPor  strongly believes that you build the company you want to work\nfor. As such, we are constantly iterating, testing new hypothesis, and\nvalidating. This document is always-changing, and we welcome thoughts,\nideas, and suggestions to improve our process.", 
            "title": "Goodbye"
        }
    ]
}